<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>React-redux-notes by Thiruppathi</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">React-redux-notes</h1>
      <h2 class="project-tagline">Study notes of React-Redux from DanAbramov&#39;s Talk</h2>
      <a href="https://github.com/Thiruppathi/react-redux-notes" class="btn">View on GitHub</a>
      <a href="https://github.com/Thiruppathi/react-redux-notes/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/Thiruppathi/react-redux-notes/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="react-redux-notes" class="anchor" href="#react-redux-notes" aria-hidden="true"><span class="octicon octicon-link"></span></a>react-redux-notes</h1>

<p>Study notes of React-Redux from DanAbramov's Talk</p>

<h2>
<a id="1-the-single-immutable-state-tree" class="anchor" href="#1-the-single-immutable-state-tree" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. The Single Immutable State Tree</h2>

<p>The first principle of Redux is, the entire application's state is managed through a Single JS Object i.e, <strong>'Single Immutable State Tree'</strong>.</p>

<p>Everything that changes within the application, including the data &amp; the UI State are contained in single JS Object called 'State Tree'.</p>

<p>In more complex applications, more state to keep track of. You can track back the state changes from this State tree.</p>

<h2>
<a id="2-describing-state-changes-with-actions" class="anchor" href="#2-describing-state-changes-with-actions" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. Describing State changes with Actions</h2>

<p>The state-tree is read-only.</p>

<p>Whenever you want to change the state, you need to dispatch an action.</p>

<p>An action is a plain js object which defines the change.</p>

<p>Just like the State is the minimial representation of data in the app, The Action is the minimal representation of the change to the data.</p>

<p>The structure of Action object is up to you, the only requirement is that it has a</p>

<p><code>type</code> property, which is not undefined.</p>

<p>Its suggested that to use "String" as it's serializable.</p>

<p>Different type of apps have Different type of actions. We don't need additional information for passing the action.</p>

<h2>
<a id="3-pure--impure-function" class="anchor" href="#3-pure--impure-function" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. Pure &amp; Impure Function</h2>

<p>Its important to understand the pure &amp; impure functions.</p>

<h3>
<a id="pure-functions" class="anchor" href="#pure-functions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Pure Functions</h3>

<p>Pure Functions are the functions whose return values are solely dependent on the parameters passed on to the functions. Pure Functions doesn't have any observable side effects such as network/database calls.</p>

<p>You can be confident that if you call a pure function, for the  same arguments, your are gonna get the same return values always. Results are predictable.</p>

<pre><code>function square(x) {
  return x * x;
}
</code></pre>

<p>Pure functions doesn't modify the values to passed to them. In the following example, the items array is not modified, instead it returns a new Array, by using items.map();</p>

<pre><code>function squareAll(items) {
  return items.map(square);
}
</code></pre>

<h3>
<a id="impure-functions" class="anchor" href="#impure-functions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Impure Functions</h3>

<p>On the opposite,  Impure functions, they may have side effects; they may call db, make network requests, they may override the values to passed to them.</p>

<pre><code>function square(x) {
  updateXinDB(x);
  return x * x;
}

function squareAll(items) {
  for(let i=0; i&lt;items.length; i++ ){
    items[i] = square(items[i]);
  }
}
</code></pre>

<h2>
<a id="4-the-reducer-function" class="anchor" href="#4-the-reducer-function" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. The Reducer Function</h2>

<p>The UI/View layer is more predictable, when it is just described as pure functions of the application state. This approach was pioneered by React.</p>

<p>Redux complements this approach with another idea.</p>

<p>The state mutation in your app should be  described as pure function.</p>

<p>That takes <code>PreviousState</code> , <code>ActionBeingDispatched</code> and return the <code>NextState</code> of your application.</p>

<p>In any redux application, there is one particular function that takes the  state of the whole application and the action being dispatched and return the next state of the whole application.</p>

<p>It is important that it doesn't modify the state to given to it. It has to be pure and should only return the next state.(new object)</p>

<p>This function is called <strong>'Reducer'</strong> Function.</p>

<h2>
<a id="5-writing-a-counter-reducer-with-tests" class="anchor" href="#5-writing-a-counter-reducer-with-tests" aria-hidden="true"><span class="octicon octicon-link"></span></a>5. Writing a counter Reducer with Tests</h2>

<p>We are going to write a Simple Counter example using Reducer.</p>

<pre><code>function counter(state, action) {
  return state;
}
</code></pre>

<p>Lets write some test cases using <code>expect</code> framework</p>

<pre><code>  expect(
    counter(0, {type:'INCREMENT'})
  ).toEqual(1);

  expect(
      counter(1, {type:'INCREMENT'})
  ).toEqual(2);

  expect(
      counter(2, {type:'DECREMENT'})
  ).toEqual(1);

  expect(
        counter(1, {type:'DECREMENT'})
  ).toEqual(0);

  console.log('Tests Passed');
</code></pre>

<p>These test gonna fail, as we've not implemented the Reducer completely.</p>

<p>Lets do that now. Based on the <code>action.type</code> we need to change the state.</p>

<pre><code>function counter(state,action) {
  if(action.type==='INCREMENT') {
    return state + 1;
  } else if(action.type==='DECREMENT') {
    return state - 1;
  }
}
</code></pre>

<p>Now the tests are passing. However if we pass an action which is not understood by the reducer, we need to maintain the current state.</p>

<pre><code>expect(
      counter(1, {type:'SOMETHING_ELSE'})
).toEqual(0);

</code></pre>

<p>Let us change the reducer to handle this.</p>

<pre><code>function counter(state,action) {
  if(action.type==='INCREMENT') {
    return state + 1;
  } else if(action.type==='DECREMENT') {
    return state - 1;
  } else {
    return state;
  }
}
</code></pre>

<p>The initial state of the application can be handled as follows</p>

<pre><code>expect(
      counter(undefined, {})
).toEqual(0);

</code></pre>

<p>This will fail the test cases.</p>

<pre><code>function counter(state,action) {
if(typeof state ==== 'undefined') {
  return 0;
}

  if(action.type==='INCREMENT') {
    return state + 1;
  } else if(action.type==='DECREMENT') {
    return state - 1;
  } else {
    return state;
  }
}
</code></pre>

<p>Let us change the schematic and use ES6 syntax.</p>

<pre><code>const counter = (state = 0,action) =&gt; {

switch(action.type) {
  case 'INCREMENT' :
    return state + 1;
  case 'DECREMENT':
    return state - 1;
  default:
  return state;
}
}
</code></pre>

<h2>
<a id="6store-methods---getstate-dispatch-and-subscribe" class="anchor" href="#6store-methods---getstate-dispatch-and-subscribe" aria-hidden="true"><span class="octicon octicon-link"></span></a>6.Store Methods - getState(), dispatch() and subscribe()</h2>

<p>The Store binds together the 3 principles of Redux.</p>

<ul>
<li>It holds the current application state object.</li>
<li>It lets you dispatch actions.</li>
<li>When they are created, you need to specify the reducer to tell how the state is updated by the Actions.</li>
</ul>

<p>The Store has 3 important methods.
react-design-diagram
1. store.getState();
2. store.dispatch({type:'INCREMENT'});
3. store.subscribe() - It lets you register a callback, that redux Store will call it whenever a Action is dispatched.
So that you can update your UI of your application.</p>

<p><a href="http://jsbin.com/nujole/2/edit?html,js,console,output">JSBin of the Demo</a></p>

<h2>
<a id="7-implementing-store-from-scratch" class="anchor" href="#7-implementing-store-from-scratch" aria-hidden="true"><span class="octicon octicon-link"></span></a>7. Implementing Store from Scratch</h2>

<p>In the previous step, we looked at how to implement a simple counter example by using createStore() provided by Redux.</p>

<p>Now we are going to re-implement createStore() provide by Redux from scratch.</p>

<p><a href="http://jsbin.com/cewote/edit?html,js,output">JS Bin of Demo</a>
Instead of using Redux createStore() as follows,</p>

<pre><code>const {createStore} = Redux;
</code></pre>

<p>We gonna create the createStore as follows.</p>

<pre><code>const createStore = (reducer) =&gt; {
  let state;
  let listeners = [];

  const getState = () =&gt; state;

  const dispatch = (action) =&gt; {
    state = reducer(state, action);
    listeners.forEach(listener =&gt; listener());
  };

  const subscribe = (listener) =&gt; {
    listeners.push(listener);
    return () =&gt; {
      listeners = listeners.filter(l =&gt; l !== listener);
    };
  };

  dispatch({});

  return {getState, dispatch, subscribe};

};
</code></pre>

<h2>
<a id="8-react-counter-example" class="anchor" href="#8-react-counter-example" aria-hidden="true"><span class="octicon octicon-link"></span></a>8. React Counter example</h2>

<p>Lets use React components to render the Counter value.</p>

<p><a href="http://jsbin.com/razemo/edit?html,js,console,output">JS Bin Demo</a></p>

<h2>
<a id="9-avoiding-array-mutation-using-concat-slice--spread" class="anchor" href="#9-avoiding-array-mutation-using-concat-slice--spread" aria-hidden="true"><span class="octicon octicon-link"></span></a>9. Avoiding Array Mutation using concat, slice &amp; ...spread</h2>

<p><a href="http://jsbin.com/zucogi">JS Bin Demo</a></p>



      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/Thiruppathi/react-redux-notes">React-redux-notes</a> is maintained by <a href="https://github.com/Thiruppathi">Thiruppathi</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>

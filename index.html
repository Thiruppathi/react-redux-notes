<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>React-redux-notes by Thiruppathi</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">React-redux-notes</h1>
      <h2 class="project-tagline">Study notes of React-Redux from DanAbramov&#39;s Talk</h2>
      <a href="https://github.com/Thiruppathi/react-redux-notes" class="btn">View on GitHub</a>
      <a href="https://github.com/Thiruppathi/react-redux-notes/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/Thiruppathi/react-redux-notes/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="react-redux-notes" class="anchor" href="#react-redux-notes" aria-hidden="true"><span class="octicon octicon-link"></span></a>react-redux-notes</h1>

<p>Study notes of React-Redux.</p>

<h2>
<a id="1-the-single-immutable-state-tree" class="anchor" href="#1-the-single-immutable-state-tree" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. The Single Immutable State Tree</h2>

<p>The first principle of Redux is, the entire application's state is managed through a Single JS Object i.e, <strong>'Single Immutable State Tree'</strong>.</p>

<p>Everything that changes within the application, including the data &amp; the UI State are contained in single JS Object called 'State Tree'.</p>

<p>In more complex applications, more state to keep track of. You can track back the state changes from this State tree.</p>

<h2>
<a id="2-describing-state-changes-with-actions" class="anchor" href="#2-describing-state-changes-with-actions" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. Describing State changes with Actions</h2>

<p>The state-tree is read-only.</p>

<p>Whenever you want to change the state, you need to dispatch an action.</p>

<p>An action is a plain js object which defines the change.</p>

<p>Just like the State is the minimial representation of data in the app, The Action is the minimal representation of the change to the data.</p>

<p>The structure of Action object is up to you, the only requirement is that it has a</p>

<p><code>type</code> property, which is not undefined.</p>

<p>Its suggested that to use "String" as it's serializable.</p>

<p>Different type of apps have Different type of actions. We don't need additional information for passing the action.</p>

<h2>
<a id="3-pure--impure-function" class="anchor" href="#3-pure--impure-function" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. Pure &amp; Impure Function</h2>

<p>Its important to understand the pure &amp; impure functions.</p>

<h3>
<a id="pure-functions" class="anchor" href="#pure-functions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Pure Functions</h3>

<p>Pure Functions are the functions whose return values are solely dependent on the parameters passed on to the functions. Pure Functions doesn't have any observable side effects such as network/database calls.</p>

<p>You can be confident that if you call a pure function, for the  same arguments, your are gonna get the same return values always. Results are predictable.</p>

<pre><code>function square(x) {
  return x * x;
}
</code></pre>

<p>Pure functions doesn't modify the values to passed to them. In the following example, the items array is not modified, instead it returns a new Array, by using items.map();</p>

<pre><code>function squareAll(items) {
  return items.map(square);
}
</code></pre>

<h3>
<a id="impure-functions" class="anchor" href="#impure-functions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Impure Functions</h3>

<p>On the opposite,  Impure functions, they may have side effects; they may call db, make network requests, they may override the values to passed to them.</p>

<pre><code>function square(x) {
  updateXinDB(x);
  return x * x;
}

function squareAll(items) {
  for(let i=0; i&lt;items.length; i++ ){
    items[i] = square(items[i]);
  }
}
</code></pre>

<h2>
<a id="4-the-reducer-function" class="anchor" href="#4-the-reducer-function" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. The Reducer Function</h2>

<p>The UI/View layer is more predictable, when it is just described as pure functions of the application state. This approach was pioneered by React.</p>

<p>Redux complements this approach with another idea.</p>

<p>The state mutation in your app should be  described as pure function.</p>

<p>That takes <code>PreviousState</code> , <code>ActionBeingDispatched</code> and return the <code>NextState</code> of your application.</p>

<p>In any redux application, there is one particular function that takes the  state of the whole application and the action being dispatched and return the next state of the whole application.</p>

<p>It is important that it doesn't modify the state to given to it. It has to be pure and should only return the next state.(new object)</p>

<p>This function is called <strong>'Reducer'</strong> Function.</p>

<h2>
<a id="5-writing-a-counter-reducer-with-tests" class="anchor" href="#5-writing-a-counter-reducer-with-tests" aria-hidden="true"><span class="octicon octicon-link"></span></a>5. Writing a counter Reducer with Tests</h2>

<p>We are going to write a Simple Counter example using Reducer.</p>

<pre><code>function counter(state, action) {
  return state;
}
</code></pre>

<p>Lets write some test cases using <code>expect</code> framework</p>

<pre><code>  expect(
    counter(0, {type:'INCREMENT'})
  ).toEqual(1);

  expect(
      counter(1, {type:'INCREMENT'})
  ).toEqual(2);

  expect(
      counter(2, {type:'DECREMENT'})
  ).toEqual(1);

  expect(
        counter(1, {type:'DECREMENT'})
  ).toEqual(0);

  console.log('Tests Passed');
</code></pre>

<p>These test gonna fail, as we've not implemented the Reducer completely.</p>

<p>Lets do that now. Based on the <code>action.type</code> we need to change the state.</p>

<pre><code>function counter(state,action) {
  if(action.type==='INCREMENT') {
    return state + 1;
  } else if(action.type==='DECREMENT') {
    return state - 1;
  }
}
</code></pre>

<p>Now the tests are passing. However if we pass an action which is not understood by the reducer, we need to maintain the current state.</p>

<pre><code>expect(
      counter(1, {type:'SOMETHING_ELSE'})
).toEqual(0);
</code></pre>

<p>Let us change the reducer to handle this.</p>

<pre><code>function counter(state,action) {
  if(action.type==='INCREMENT') {
    return state + 1;
  } else if(action.type==='DECREMENT') {
    return state - 1;
  } else {
    return state;
  }
}
</code></pre>

<p>The initial state of the application can be handled as follows</p>

<pre><code>expect(
      counter(undefined, {})
).toEqual(0);
</code></pre>

<p>This will fail the test cases.</p>

<pre><code>function counter(state,action) {
if(typeof state ==== 'undefined') {
  return 0;
}

  if(action.type==='INCREMENT') {
    return state + 1;
  } else if(action.type==='DECREMENT') {
    return state - 1;
  } else {
    return state;
  }
}
</code></pre>

<p>Let us change the schematic and use ES6 syntax.</p>

<pre><code>const counter = (state = 0,action) =&gt; {

switch(action.type) {
  case 'INCREMENT' :
    return state + 1;
  case 'DECREMENT':
    return state - 1;
  default:
  return state;
}
}
</code></pre>

<h2>
<a id="6store-methods---getstate-dispatch-and-subscribe" class="anchor" href="#6store-methods---getstate-dispatch-and-subscribe" aria-hidden="true"><span class="octicon octicon-link"></span></a>6.Store Methods - getState(), dispatch() and subscribe()</h2>

<p>The Store binds together the 3 principles of Redux.</p>

<ul>
<li>It holds the current application state object.</li>
<li>It lets you dispatch actions.</li>
<li>When they are created, you need to specify the reducer to tell how the state is updated by the Actions.</li>
</ul>

<p>The Store has 3 important methods. react-design-diagram
1. store.getState();
2. store.dispatch({type:'INCREMENT'});
3. store.subscribe() - It lets you register a callback, that redux Store will call it whenever a Action is dispatched.
4. So that you can update your UI of your application.</p>

<p><a href="http://jsbin.com/nujole/2/edit?html,js,console,output">JSBin of the Demo</a></p>

<h2>
<a id="7-implementing-store-from-scratch" class="anchor" href="#7-implementing-store-from-scratch" aria-hidden="true"><span class="octicon octicon-link"></span></a>7. Implementing Store from Scratch</h2>

<p>In the previous step, we looked at how to implement a simple counter example by using createStore() provided by Redux.</p>

<p>Now we are going to re-implement createStore() provide by Redux from scratch.</p>

<p><a href="http://jsbin.com/cewote/edit?html,js,output">JS Bin of Demo</a> Instead of using Redux createStore() as follows,</p>

<pre><code>const {createStore} = Redux;
</code></pre>

<p>We gonna create the createStore as follows.</p>

<pre><code>const createStore = (reducer) =&gt; {
  let state;
  let listeners = [];

  const getState = () =&gt; state;

  const dispatch = (action) =&gt; {
    state = reducer(state, action);
    listeners.forEach(listener =&gt; listener());
  };

  const subscribe = (listener) =&gt; {
    listeners.push(listener);
    return () =&gt; {
      listeners = listeners.filter(l =&gt; l !== listener);
    };
  };

  dispatch({});

  return {getState, dispatch, subscribe};

};
</code></pre>

<h2>
<a id="8-react-counter-example" class="anchor" href="#8-react-counter-example" aria-hidden="true"><span class="octicon octicon-link"></span></a>8. React Counter example</h2>

<p>Lets use React components to render the Counter value.</p>

<p><a href="http://jsbin.com/razemo/edit?html,js,console,output">JS Bin Demo</a></p>

<h2>
<a id="9-avoiding-array-mutation-using-concat-slice--spread" class="anchor" href="#9-avoiding-array-mutation-using-concat-slice--spread" aria-hidden="true"><span class="octicon octicon-link"></span></a>9. Avoiding Array Mutation using concat, slice &amp; ...spread</h2>

<p><a href="http://jsbin.com/zucogi">JS Bin Demo</a></p>



<h2>
<a id="10-avoid-object-mutation-with-objectassign-and-spread" class="anchor" href="#10-avoid-object-mutation-with-objectassign-and-spread" aria-hidden="true"><span class="octicon octicon-link"></span></a>10. Avoid Object Mutation with Object.assign() and ...spread</h2>

<p><a href="http://jsbin.com/zoveqo/3/edit">JS Bin Demo</a></p>

<pre><code>
const toggleTodo = (todo) =&gt; {
  return {
    ...todo,
    completed: !todo.completed
  };
};

/*
const toggleTodo = (todo) =&gt; {
  return Object.assign({}, todo, {
    completed: !todo.completed
  });
};
*/

const testToggleTodo = () =&gt; {

  const todoBefore = {
    id:0,
    text: 'Learn Redux',
    completed: false
  };

    const todoAfter = {
    id:0,
    text: 'Learn Redux',
    completed: true
  };

  deepFreeze(todoBefore);
  expect(toggleTodo(todoBefore)).toEqual(todoAfter);

};

testToggleTodo();

console.log('All tests Passed.');
</code></pre>

<p>You can use <code>Object.assign()</code> or ...spread operator to mutate Object.</p>

<p>When using <code>Object.assign()</code> use a Polyfill to support evergreen browsers.</p>

<h2>
<a id="11-writing-a-todo-list-reducer--adding-a-todo" class="anchor" href="#11-writing-a-todo-list-reducer--adding-a-todo" aria-hidden="true"><span class="octicon octicon-link"></span></a>11. Writing a ToDo List Reducer ( Adding a ToDo)</h2>

<p><a href="http://jsbin.com/tenizo/edit?js,console">JS Bin Demo</a></p>

<pre><code>const todos = (state=[],action) =&gt; {
  switch(action.type) {
    case 'ADD_TODO':
      return[
        ...state,
        {
          id: action.id,
          text: action.text,
          completed: false
        }
      ];
    default:
      return state;
  }
};

const testAddTodo = () =&gt; {
  const stateBefore = [];
  const action = {
    type: 'ADD_TODO',
    id: 0,
    text: 'Learn Redux'
  };

  const stateAfter = [
    {
      id:0,
      text:'Learn Redux',
      completed: false
    }
  ];

  deepFreeze(stateBefore);
    deepFreeze(action);

  expect(
    todos(stateBefore, action)
  ).toEqual(stateAfter);
};

testAddTodo();
console.log('All tests passed.');
</code></pre>

<h2>
<a id="12-writing-a-todo-list-reducer---toggling-a-todo" class="anchor" href="#12-writing-a-todo-list-reducer---toggling-a-todo" aria-hidden="true"><span class="octicon octicon-link"></span></a>12. Writing a Todo List Reducer - Toggling a Todo</h2>

<p><a href="http://jsbin.com/moyepe/edit?js,console">JS Bin Demo</a></p>

<pre><code>const todos = (state=[],action) =&gt; {
  switch(action.type) {
    case 'ADD_TODO':
      return[
        ...state,
        {
          id: action.id,
          text: action.text,
          completed: false
        }
      ];
        case 'TOGGLE_TODO':
            return state.map(todo =&gt; {
                if(todo.id !== action.id) {
                    return todo;
                }

                return {...todo, completed: !todo.completed };
            });
    default:
      return state;
  }
};



const testAddTodo = () =&gt; {
  const stateBefore = [];
  const action = {
    type: 'ADD_TODO',
    id: 0,
    text: 'Learn Redux'
  };

  const stateAfter = [
    {
      id:0,
      text:'Learn Redux',
      completed: false
    }
  ];

  deepFreeze(stateBefore);
    deepFreeze(action);

  expect(
    todos(stateBefore, action)
  ).toEqual(stateAfter);
};

const testToggleTodo = () =&gt; {
  const stateBefore = [
    {
      id:0,
      text:'Learn Redux',
      completed: false
    },
        {
      id:1,
      text:'Learn NodeJS',
      completed: false
    }
  ];  
  const action = {
    type: 'TOGGLE_TODO',
    id: 1
  };
    const stateAfter = [
    {
      id:0,
      text:'Learn Redux',
      completed: false
    },
        {
      id:1,
      text:'Learn NodeJS',
      completed: true
    }
  ];  


  deepFreeze(stateBefore);
    deepFreeze(action);

  expect(
    todos(stateBefore, action)
  ).toEqual(stateAfter);
};

testAddTodo();
testToggleTodo();
console.log('All tests passed.')
</code></pre>

<h2>
<a id="13-reducer-composition-with-arrays" class="anchor" href="#13-reducer-composition-with-arrays" aria-hidden="true"><span class="octicon octicon-link"></span></a>13. Reducer Composition with Arrays</h2>

<p><a href="http://jsbin.com/mumaya/edit?js,console">JS Bin Demo</a></p>

<pre><code>const todo = (state, action) =&gt; {
    switch(action.type) {
        case 'ADD_TODO':
            return {
                id: action.id,
                text: action.text,
                completed: false
            };
        case 'TOGGLE_TODO':
            if(state.id !== action.id) {
                return state;
            }

            return {
                ...state,
                completed: !state.completed
            };
        default:
            return state;
    }
};


const todos = (state=[],action) =&gt; {
  switch(action.type) {
    case 'ADD_TODO':
      return[
        ...state,
        todo(undefined, action)
      ];
        case 'TOGGLE_TODO':
            return state.map(t =&gt; todo(t,action));
    default:
      return state;
  }
};
</code></pre>

<h2>
<a id="14-reducer-composition-with-objects" class="anchor" href="#14-reducer-composition-with-objects" aria-hidden="true"><span class="octicon octicon-link"></span></a>14. Reducer Composition with Objects</h2>

<p><a href="http://jsbin.com/wivutu/edit?js,console">JS Bin Demo</a></p>

<pre><code>const todo = (state, action) =&gt; {
    switch(action.type) {
        case 'ADD_TODO':
            return {
                id: action.id,
                text: action.text,
                completed: false
            };
        case 'TOGGLE_TODO':
            if(state.id !== action.id) {
                return state;
            }

            return {
                ...state,
                completed: !state.completed
            };
        default:
            return state;
    }
};


const todos = (state=[],action) =&gt; {
  switch(action.type) {
    case 'ADD_TODO':
      return[
        ...state,
        todo(undefined, action)
      ];
        case 'TOGGLE_TODO':
            return state.map(t =&gt; todo(t,action));
    default:
      return state;
  }
};


const visibilityFilter = (
  state = 'SHOW_ALL',
  action
  ) =&gt; {
    switch(action.type) {
        case 'SET_VISIBILITY_FILTER':
            return action.filter;
        default:
            return state;
    }
};


const todoApp = (state ={}, action) =&gt; {
    return {
        todos: todo(state.todos, action),
        visibilityFilter: visibilityFilter(state.visibilityFilter, action)
    };
};


const {createStore} = Redux;
const store = createStore(todoApp);
</code></pre>

<h2>
<a id="15-reducer-composition-with-combinereducers" class="anchor" href="#15-reducer-composition-with-combinereducers" aria-hidden="true"><span class="octicon octicon-link"></span></a>15. Reducer Composition with combineReducers()</h2>

<p><a href="http://jsbin.com/puqalo/edit?js,console">JS Bin Demo</a></p>

<pre><code>const todoApp = (state ={}, action) =&gt; {
    return {
        todos: todo(state.todos, action),
        visibilityFilter: visibilityFilter(state.visibilityFilter, action)
    };
};
</code></pre>

<p>This pattern is so common in most of the Redux-Apps.</p>

<p>Thats why Redux provides a function called <code>{combineReducers}</code></p>

<pre><code>const {combineReducers} = Redux;

const todoApp = combineReducers ({
  todos: todos,
  visibilityFilter : visibilityFilter
  });
</code></pre>

<p>The Keys of the object that configured in the combineReducers denotes the fields  of the state object.</p>

<p>The Values of the object that configured in the combineReducers denotes the reducers it should call to update the corresponding state fields.</p>

<p>Let's establish a useful convention.  I'll always name my Reducers after the state keys they manage.</p>

<p>Thanks to ES6 Object literal shorthand notation.</p>

<pre><code>const {combineReducers} = Redux;

const todoApp = combineReducers ({ todos,  visibilityFilter  });
</code></pre>

<h2>
<a id="16-implementing-combinereducers-from-scratch" class="anchor" href="#16-implementing-combinereducers-from-scratch" aria-hidden="true"><span class="octicon octicon-link"></span></a>16. Implementing combineReducers() from Scratch</h2>

<p><a href="http://jsbin.com/tazuzi/edit?js,console">JS Bin Demo</a></p>

<p>To gain deeper understanding of combineReducers works, let us implement it from Scratch.</p>

<pre><code>const combineReducers = (reducers) =&gt; {
  return (state = {}, action) =&gt; {
    return Object.keys(reducers).reduce(
      (nextState, key) =&gt; {
        nextState[key] = reducers[key](
          state[key],
          action
        );
        return nextState;
      }, {}
    );
  };
};
</code></pre>

<h2>
<a id="17-react-todo-list-example-adding-a-todo" class="anchor" href="#17-react-todo-list-example-adding-a-todo" aria-hidden="true"><span class="octicon octicon-link"></span></a>17. React ToDo List Example (Adding a ToDo)</h2>

<p><a href="http://jsbin.com/nimeqe/edit?html,js,output">JS Bin Demo</a></p>

<pre><code>
const { Component } = React;

let nextTodoId = 0;

class TodoApp extends Component {
    render() {
        return (
          &lt;div&gt;
            &lt;input ref={ node =&gt; {
            this.input = node;
            }} /&gt;
              &lt;button onClick={()=&gt; {
                store.dispatch({
                        type: 'ADD_TODO',
                        text: this.input.value,
                        id: nextTodoId++
                    });
            this.input.value = '';
        }}&gt;
      Add Todo
        &lt;/button&gt;
        &lt;ul&gt;
            {this.props.todos.map(todo =&gt;
             &lt;li key = {todo.id}&gt;
              {todo.text}
            &lt;/li&gt;
             )}
        &lt;/ul&gt;
            &lt;/div&gt;
        );
    }
}

const render = () =&gt; {
    ReactDOM.render(
    &lt;TodoApp
        todos={store.getState().todos}
  /&gt;,
    document.getElementById('root')
    );
};

store.subscribe(render);
render();
</code></pre>

<h2>
<a id="18-react-todo-list-example-toggling-a-todo" class="anchor" href="#18-react-todo-list-example-toggling-a-todo" aria-hidden="true"><span class="octicon octicon-link"></span></a>18. React ToDo List Example (Toggling a ToDo)</h2>

<p><a href="http://jsbin.com/kozaba/edit?html,js,output">JS Bin Demo</a></p>

<pre><code>&lt;ul&gt;
  {this.props.todos.map(todo =&gt;
   &lt;li  key = {todo.id}
        onClick={()=&gt;{
                 store.dispatch({
                 type: 'TOGGLE_TODO',
                 id: todo.id
                });
        }}
        style = {{
          textDecoration: todo.completed ? 'line-through' : 'none'
                }}&gt;
  {todo.text}
  &lt;/li&gt;
   )}
&lt;/ul&gt;
</code></pre>

<h2>
<a id="19-react-todo-list-example-filtering-a-todo" class="anchor" href="#19-react-todo-list-example-filtering-a-todo" aria-hidden="true"><span class="octicon octicon-link"></span></a>19. React ToDo List Example (Filtering a ToDo)</h2>

<p><a href="http://jsbin.com/zedafi/edit?html,js,output">JS Bin Demo</a></p>

<pre><code>const FilterLink = ({
  filter,
  currentFilter,
  children
}) =&gt; {
  if (filter === currentFilter) {
    return &lt;span &gt; {
      children
    } &lt; /span&gt;;
  }
  return ( &lt; a href = '#'
    onClick = {
      e =&gt; {
        e.preventDefault();
        store.dispatch({
          type: 'SET_VISIBILITY_FILTER',
          filter
        });
      }
    } &gt; {
      children
    } &lt; /a&gt;
  );

};
</code></pre>

<pre><code>const getVisibleTodos = (
  todos, filter
) =&gt; {
  switch (filter) {
    case 'SHOW_ALL':
      return todos;
    case 'SHOW_COMPLETED':
      return todos.filter(t =&gt; t.completed);
    case 'SHOW_ACTIVE':
      return todos.filter(t =&gt; !t.completed);
  }
};
</code></pre>

<pre><code>&lt; p &gt;
  Show: {
    ' '
  } &lt; FilterLink filter = 'SHOW_ALL'
currentFilter = {
  visibilityFilter
} &gt; All &lt; /FilterLink&gt; {
' '
} &lt; FilterLink filter = 'SHOW_ACTIVE'
currentFilter = {
  visibilityFilter
} &gt; Active &lt; /FilterLink&gt; {
' '
} &lt; FilterLink filter = 'SHOW_COMPLETED'
currentFilter = {
  visibilityFilter
} &gt; Completed &lt; /FilterLink&gt; &lt; /p &gt;

</code></pre>

<h2>
<a id="20-extracting-presentational-components-todo-todo-list" class="anchor" href="#20-extracting-presentational-components-todo-todo-list" aria-hidden="true"><span class="octicon octicon-link"></span></a>20. Extracting Presentational components (ToDo, ToDo List)</h2>

<p><a href="http://jsbin.com/nefefi/edit?js,output">JS Bin Demo</a></p>

<p>Let's Extract the ToDo Component.</p>

<pre><code>const Todo = ({ onClick,completed, text }) =&gt; (
    &lt;li
      onClick = {onClick}
    style = {{textDecoration: completed ? 'line-through' : 'none'}}&gt;
        {text}
    &lt;/li&gt;
);
</code></pre>

<p>Now, Extract the TodoList Component.</p>

<pre><code>const TodoList = ({ todos,  onTodoClick }) =&gt; (
    &lt;ul&gt;
      {todos.map(todo =&gt;
                  &lt;Todo
                    key={todo.id}
              {...todo}
              onClick={() =&gt; onTodoClick(todo.id)}
          /&gt;
      )}
    &lt;/ul&gt;
);

</code></pre>

<p>Now, in the render method, repalce the <code>&lt;ul&gt;</code> with our extracted component.</p>

<pre><code>&lt;TodoList
  todos = {visibleTodos}
   onTodoClick = {id =&gt;
      store.dispatch({
        type: 'TOGGLE_TODO',
        id
      })
  } /&gt;
</code></pre>

<h2>
<a id="21-extracting-presentational-components-add-todo-footer-filter-link" class="anchor" href="#21-extracting-presentational-components-add-todo-footer-filter-link" aria-hidden="true"><span class="octicon octicon-link"></span></a>21. Extracting Presentational components (Add ToDo, Footer, Filter Link)</h2>

<p><a href="http://jsbin.com/tedoqi/edit?html,js,output">JS Bin Demo</a></p>

<p>Add ToDo</p>

<pre><code>const AddTodo = ({onAddClick}) =&gt; {
    let input;

    return (
      &lt;div&gt;
        &lt;input ref = { node =&gt; {input = node;}}/&gt;
        &lt;button onClick = { () =&gt; {
                            onAddClick(input.value);
                            input.value = '';
                    }}&gt;
                        Add Todo
        &lt;/button&gt;
            &lt;/div&gt;
            );
};
</code></pre>

<p>Footer</p>

<pre><code>const Footer = ({visibilityFilter, onFilterClick}) =&gt; (
                &lt;p&gt;
           Show :
             {' '}
             &lt;FilterLink filter = 'SHOW_ALL'  currentFilter = {visibilityFilter} onClick={onFilterClick}&gt;
                             All
                         &lt;/FilterLink&gt;
             {' ,  '}
             &lt;FilterLink filter = 'SHOW_ACTIVE'  currentFilter = {visibilityFilter} onClick={onFilterClick}&gt;
                             Active
                         &lt;/FilterLink&gt;
             {' ,  '}
             &lt;FilterLink filter = 'SHOW_COMPLETED'  currentFilter = {visibilityFilter} onClick={onFilterClick}&gt;
                             Completed
                         &lt;/FilterLink&gt;
        &lt;/p&gt;
);
</code></pre>

<p>Filter Link</p>

<pre><code>const FilterLink = ({ filter, currentFilter, children, onClick }) =&gt; {

    if (filter === currentFilter) {
    return &lt;span&gt; {children} &lt;/span&gt;;
    }

    return (
        &lt;a
        href = '#'
        onClick = { e =&gt; {
                    e.preventDefault();
                    onClick(filter)
                  }
        }&gt;
      {children}
    &lt;/a&gt;
  );
};
</code></pre>

<p>The final ToDoApp component</p>

<pre><code>const TodoApp = ({todos, visibilityFilter}) =&gt; (
      &lt;div&gt;

            &lt;AddTodo
                  onAddClick={text=&gt;
                    store.dispatch({
                      type:'ADD_TODO',
                      id:nextTodoId++,
                      text
                })
                  }
        /&gt;

        &lt;TodoList
          todos = {getVisibleTodos(todos, visibilityFilter)}
             onTodoClick = {id =&gt;
              store.dispatch({
                type: 'TOGGLE_TODO',
                id
              })
          } /&gt;

                    &lt;Footer
                      visibilityFilter={visibilityFilter}
                        onFilterClick={filter =&gt;
                          store.dispatch({
                                    type: 'SET_VISIBILITY_FILTER',
                                    filter
                                    })
                        }
                    /&gt;
      &lt;/div&gt;
    );
</code></pre>

<p>Separation of Presentational Component, decouples the rendering from REDUX.</p>

<p>This has a downside of passing too many properties to the component, which can be resolved using <strong>Container Components</strong>.</p>

<h2>
<a id="22-extracting-container-components-filter-link" class="anchor" href="#22-extracting-container-components-filter-link" aria-hidden="true"><span class="octicon octicon-link"></span></a>22. Extracting Container components (Filter Link)</h2>

<p><a href="http://jsbin.com/woloqo/edit?html,js,output">JS Bin Demo</a></p>

<p>In previous step, <strong>Footer</strong> component passes down <code>visibilityFilter</code> and <code>onFilterClick</code> to the <strong>FilterLink</strong> component, even though <strong>Footer</strong> doesn't use this properties directly.</p>

<p>In this way, it breaks encapsulation where the <strong>ParentComponent</strong> needs to know too much about the <strong>ChildComponent</strong>.</p>

<p>Thats why we need to extract the <strong>Container Components</strong>, just like the way we extracted <strong>Presentational Components</strong>.</p>

<p>Let's start refactoring with the <strong>Footer</strong> component by removing the properties <code>visibilityFilter</code> and <code>onFilterClick</code>.</p>

<p>In from ToDoApp Component,</p>

<pre><code>&lt;Footer /&gt;
</code></pre>

<p>And from the Footer Component</p>

<pre><code>const Footer = () =&gt; (
                &lt;p&gt;
           Show :
             {' '}
             &lt;FilterLink filter = 'SHOW_ALL'&gt;All&lt;/FilterLink&gt;
             {' ,  '}
             &lt;FilterLink filter = 'SHOW_ACTIVE'&gt;Active&lt;/FilterLink&gt;
             {' ,  '}
             &lt;FilterLink filter = 'SHOW_COMPLETED'&gt;Completed&lt;/FilterLink&gt;
        &lt;/p&gt;
);
</code></pre>

<p>This may seem like the same component before extracting to <strong>Presentational Component</strong>.</p>

<p>But what we are going to do is bit Different.</p>

<p>Let's have a look at <strong>Filter</strong> Component.</p>

<pre><code>const FilterLink = ({ filter, currentFilter, children, onClick }) =&gt; {

    if (filter === currentFilter) {
    return &lt;span&gt; {children} &lt;/span&gt;;
    }

    return (
        &lt;a
        href = '#'
        onClick = { e =&gt; {
                    e.preventDefault();
                    onClick(filter)
                  }
        }&gt;
      {children}
    &lt;/a&gt;
  );
};
</code></pre>

<p>The FilterLink</p>

<ul>
<li>doesn't specify the behaviour for Clicking on the link.</li>
<li>It also needs the current filter to tell whether its active or not to render.</li>
</ul>

<p>Honestly, this is not a <strong>Presentational Component</strong>, because its not separable with its behaviour.</p>

<p>The only reasonable  reaction to clicking on it is to set visibilityFilter by dispatching an action.</p>

<p>This is why we should change it different <strong>Presentational Component</strong> as follows.</p>

<pre><code>const Link = ({ active, children, onClick }) =&gt; {

    if (active) {
    return &lt;span&gt; {children} &lt;/span&gt;;
    }

    return (
        &lt;a
        href = '#'
        onClick = { e =&gt; {
              e.preventDefault();
            onClick();
        }}
        &gt;
            {children}
    &lt;/a&gt;
  );
};
</code></pre>

<p>The <strong>Link</strong> component doesn't know anything about filtering.</p>

<ul>
<li>It only accepts <code>active</code> property</li>
<li>Handles click through <code>onClick()</code>
</li>
</ul>

<p>Let us create another component <strong>FilterLink</strong> as a container that uses <strong>Link</strong> to render it.
Its gonna render the <strong>Link</strong> from the current data from <code>store</code>.</p>

<p>Its going to</p>

<ul>
<li>read the props from the component props.</li>
<li>read the state from redux's store state</li>
</ul>

<pre><code>class FilterLink extends Component {

    render() {
        const props = this.props;
        const state = store.getState();
    }
}

</code></pre>

<p>As a <strong>Container Component</strong> the <strong>FilterLink</strong> doesn't have its own mark up.
It delegates the rendering through the <strong>Link Presentational Component</strong>.</p>

<p>In this case it calculates it's <code>active</code> props, by comparing with the redux store state's <code>visibilityFilter</code>.</p>

<p>The <code>filter</code> props is the one we passed from the <strong>Footer</strong> component.
The <code>visibilityFilter</code> corresponds to the currently chosen <code>visibilityFilter</code>.</p>

<p>I these 2 filters matches, then we make the link to appear active.</p>

<pre><code>&lt;Link  
    active = { props.filter === state.visibilityFilter } &gt;
&lt;/Link&gt;
</code></pre>

<p>The Container Component also needs to define the  <strong>behaviour</strong>.</p>

<p>In this case, the <strong>FilterLink</strong> specifies when this particular link is clicked,</p>

<ul>
<li>dispatch an <code>action</code> with the type <code>SET_VISIBILITY_FILTER</code>
</li>
<li>take the <code>filter</code> value from the props</li>
</ul>

<p>The filter link may contain children which is used as content of the <strong>Link</strong></p>

<pre><code>&lt;Link
  active = { props.filter === state.visibilityFilter }
  onClick={() =&gt;
    store.dispatch({
      type: 'SET_VISIBILITY_FILTER',
      filter: props.filter
    })
  }&gt;
  {props.children}
&lt;/Link&gt;
</code></pre>

<p>return this <code>Link</code> markup and the <code>FilterComponent</code> becomes like this.</p>

<pre><code>class FilterLink extends Component {

 render() {
   const props = this.props;
   const state = store.getState();

   return (
     &lt;Link
       active = { props.filter === state.visibilityFilter }
       onClick={() =&gt;
         store.dispatch({
           type: 'SET_VISIBILITY_FILTER',
           filter: props.filter
         })
       }
     &gt; {props.children}
     &lt;/Link&gt;
   );
 }
}

</code></pre>

<p>There is a small problem with the implementation of <strong>FilterLink</strong>.
Inside the <code>render()</code> it reads the current state of the ReduxStore, but it is not subscribed to the Store.</p>

<p>So if the ParentComponent doesn't updated when the store is updated,
its going to render the child value.</p>

<p>Currently we re-render the whole application when the state changes, which is not efficient.</p>

<p>So in future, we will move subscription to the store to the LifeCycle methods of <strong>Container Component</strong>.</p>

<p>React provides a special <code>forceUpdate()</code> method on the component instances.</p>

<p>To force the re-rendering. And we are going to use it inside <code>store.subscribe()</code> ,
so that whenever the store's state changes we can forceUpdate the <strong>Container Component</strong></p>

<pre><code>componentDidMount() {
  store.subscribe(()=&gt;
    this.forceUpdate()
  );
}
</code></pre>

<p>We did the <code>forceUpdate</code> inside <code>componentDidMount()</code>. We need to <code>unsubscribe</code> inside <code>componentWillUnMount()</code></p>

<pre><code>componentWillUnMount() {
  this.unsubscribe();
}

</code></pre>

<p>React doesn't provide <code>unsubscribe()</code> . Its a return value from <code>store.subscribe()</code>.</p>

<pre><code>componentDidMount() {
  this.unsubscribe = store.subscribe(()=&gt;
    this.forceUpdate()
  );
}

componentWillUnMount() {
  this.unsubscribe();
}
</code></pre>

<p>So our <code>FilterLink</code> becomes like this.</p>

<pre><code>class FilterLink extends Component {

    componentDidMount() {
        this.unsubscribe = store.subscribe(()=&gt;
            this.forceUpdate()
        );
    }

    componentWillUnMount() {
        this.unsubscribe();
    }


    render() {
        const props = this.props;
        const state = store.getState();

        return (
          &lt;Link
              active = {
                props.filter === state.visibilityFilter
              }
              onClick={() =&gt;
                  store.dispatch({
                  type: 'SET_VISIBILITY_FILTER',
                  filter: props.filter
            })
          }
        &gt; {props.children}
            &lt;/Link&gt;
        );
    }
}

</code></pre>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/Thiruppathi/react-redux-notes">React-redux-notes</a> is maintained by <a href="https://github.com/Thiruppathi">Thiruppathi</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>

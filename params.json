{"name":"React-redux-notes","tagline":"Study notes of React-Redux from DanAbramov's Talk","body":"# react-redux-notes\r\nStudy notes of React-Redux from DanAbramov's Talk\r\n\r\n## 1. The Single Immutable State Tree\r\nThe first principle of Redux is, the entire application's state is managed through a Single JS Object i.e, **'Single Immutable State Tree'**.\r\n\r\nEverything that changes within the application, including the data & the UI State are contained in single JS Object called 'State Tree'.\r\n\r\nIn more complex applications, more state to keep track of. You can track back the state changes from this State tree.\r\n\r\n## 2. Describing State changes with Actions\r\nThe state-tree is read-only.\r\n\r\nWhenever you want to change the state, you need to dispatch an action.\r\n\r\nAn action is a plain js object which defines the change.\r\n\r\nJust like the State is the minimial representation of data in the app, The Action is the minimal representation of the change to the data.\r\n\r\nThe structure of Action object is up to you, the only requirement is that it has a\r\n\r\n`type` property, which is not undefined.\r\n\r\nIts suggested that to use \"String\" as it's serializable.\r\n\r\nDifferent type of apps have Different type of actions. We don't need additional information for passing the action.\r\n\r\n## 3. Pure & Impure Function\r\nIts important to understand the pure & impure functions.\r\n\r\n### Pure Functions\r\nPure Functions are the functions whose return values are solely dependent on the parameters passed on to the functions. Pure Functions doesn't have any observable side effects such as network/database calls.\r\n\r\nYou can be confident that if you call a pure function, for the  same arguments, your are gonna get the same return values always. Results are predictable.\r\n\r\n```\r\nfunction square(x) {\r\n  return x * x;\r\n}\r\n```\r\n\r\nPure functions doesn't modify the values to passed to them. In the following example, the items array is not modified, instead it returns a new Array, by using items.map();\r\n\r\n```\r\nfunction squareAll(items) {\r\n  return items.map(square);\r\n}\r\n```\r\n\r\n### Impure Functions\r\nOn the opposite,  Impure functions, they may have side effects; they may call db, make network requests, they may override the values to passed to them.\r\n\r\n```\r\nfunction square(x) {\r\n  updateXinDB(x);\r\n  return x * x;\r\n}\r\n\r\nfunction squareAll(items) {\r\n  for(let i=0; i<items.length; i++ ){\r\n    items[i] = square(items[i]);\r\n  }\r\n}\r\n```\r\n\r\n## 4. The Reducer Function\r\nThe UI/View layer is more predictable, when it is just described as pure functions of the application state. This approach was pioneered by React.\r\n\r\nRedux complements this approach with another idea.\r\n\r\nThe state mutation in your app should be  described as pure function.\r\n\r\nThat takes `PreviousState` , `ActionBeingDispatched` and return the `NextState` of your application.\r\n\r\nIn any redux application, there is one particular function that takes the  state of the whole application and the action being dispatched and return the next state of the whole application.\r\n\r\nIt is important that it doesn't modify the state to given to it. It has to be pure and should only return the next state.(new object)\r\n\r\nThis function is called **'Reducer'** Function.\r\n\r\n## 5. Writing a counter Reducer with Tests\r\nWe are going to write a Simple Counter example using Reducer.\r\n\r\n```\r\nfunction counter(state, action) {\r\n  return state;\r\n}\r\n```\r\n\r\nLets write some test cases using `expect` framework\r\n\r\n```\r\n  expect(\r\n    counter(0, {type:'INCREMENT'})\r\n  ).toEqual(1);\r\n\r\n  expect(\r\n      counter(1, {type:'INCREMENT'})\r\n  ).toEqual(2);\r\n\r\n  expect(\r\n      counter(2, {type:'DECREMENT'})\r\n  ).toEqual(1);\r\n\r\n  expect(\r\n        counter(1, {type:'DECREMENT'})\r\n  ).toEqual(0);\r\n\r\n  console.log('Tests Passed');\r\n```\r\n\r\nThese test gonna fail, as we've not implemented the Reducer completely.\r\n\r\nLets do that now. Based on the ``action.type`` we need to change the state.\r\n\r\n```\r\nfunction counter(state,action) {\r\n  if(action.type==='INCREMENT') {\r\n    return state + 1;\r\n  } else if(action.type==='DECREMENT') {\r\n    return state - 1;\r\n  }\r\n}\r\n```\r\n\r\nNow the tests are passing. However if we pass an action which is not understood by the reducer, we need to maintain the current state.\r\n\r\n```\r\nexpect(\r\n      counter(1, {type:'SOMETHING_ELSE'})\r\n).toEqual(0);\r\n\r\n```\r\n\r\nLet us change the reducer to handle this.\r\n\r\n```\r\nfunction counter(state,action) {\r\n  if(action.type==='INCREMENT') {\r\n    return state + 1;\r\n  } else if(action.type==='DECREMENT') {\r\n    return state - 1;\r\n  } else {\r\n    return state;\r\n  }\r\n}\r\n```\r\n\r\nThe initial state of the application can be handled as follows\r\n\r\n```\r\nexpect(\r\n      counter(undefined, {})\r\n).toEqual(0);\r\n\r\n```\r\nThis will fail the test cases.\r\n```\r\nfunction counter(state,action) {\r\nif(typeof state ==== 'undefined') {\r\n  return 0;\r\n}\r\n\r\n  if(action.type==='INCREMENT') {\r\n    return state + 1;\r\n  } else if(action.type==='DECREMENT') {\r\n    return state - 1;\r\n  } else {\r\n    return state;\r\n  }\r\n}\r\n```\r\n\r\nLet us change the schematic and use ES6 syntax.\r\n\r\n```\r\nconst counter = (state = 0,action) => {\r\n\r\nswitch(action.type) {\r\n  case 'INCREMENT' :\r\n    return state + 1;\r\n  case 'DECREMENT':\r\n    return state - 1;\r\n  default:\r\n  return state;\r\n}\r\n}\r\n```\r\n\r\n## 6.Store Methods - getState(), dispatch() and subscribe()\r\n\r\nThe Store binds together the 3 principles of Redux.\r\n\r\n- It holds the current application state object.\r\n- It lets you dispatch actions.\r\n- When they are created, you need to specify the reducer to tell how the state is updated by the Actions.\r\n\r\nThe Store has 3 important methods.\r\nreact-design-diagram\r\n1. store.getState();\r\n2. store.dispatch({type:'INCREMENT'});\r\n3. store.subscribe() - It lets you register a callback, that redux Store will call it whenever a Action is dispatched.\r\nSo that you can update your UI of your application.\r\n\r\n[JSBin of the Demo](http://jsbin.com/nujole/2/edit?html,js,console,output)\r\n\r\n## 7. Implementing Store from Scratch\r\nIn the previous step, we looked at how to implement a simple counter example by using createStore() provided by Redux.\r\n\r\nNow we are going to re-implement createStore() provide by Redux from scratch.\r\n\r\n[JS Bin of Demo](http://jsbin.com/cewote/edit?html,js,output)\r\nInstead of using Redux createStore() as follows,\r\n\r\n```\r\nconst {createStore} = Redux;\r\n```\r\n\r\nWe gonna create the createStore as follows.\r\n\r\n```\r\nconst createStore = (reducer) => {\r\n  let state;\r\n  let listeners = [];\r\n\r\n  const getState = () => state;\r\n\r\n  const dispatch = (action) => {\r\n    state = reducer(state, action);\r\n    listeners.forEach(listener => listener());\r\n  };\r\n\r\n  const subscribe = (listener) => {\r\n    listeners.push(listener);\r\n    return () => {\r\n      listeners = listeners.filter(l => l !== listener);\r\n    };\r\n  };\r\n\r\n  dispatch({});\r\n\r\n  return {getState, dispatch, subscribe};\r\n\r\n};\r\n```\r\n\r\n## 8. React Counter example\r\nLets use React components to render the Counter value.\r\n\r\n[JS Bin Demo](http://jsbin.com/razemo/edit?html,js,console,output)\r\n\r\n## 9. Avoiding Array Mutation using concat, slice & ...spread\r\n\r\n[JS Bin Demo](http://jsbin.com/zucogi)\r\n\r\n<script src=\"https://gist.github.com/anonymous/2b9775562a5c4d01abd7.js\"></script>\r\n\r\n## 10. Avoid Object Mutation with Object.assign() and ...spread\r\n\r\n[JS Bin Demo](http://jsbin.com/zoveqo/3/edit)\r\n\r\n```\r\n\r\nconst toggleTodo = (todo) => {\r\n  return {\r\n    ...todo,\r\n    completed: !todo.completed\r\n  };\r\n};\r\n\r\n/*\r\nconst toggleTodo = (todo) => {\r\n  return Object.assign({}, todo, {\r\n    completed: !todo.completed\r\n  });\r\n};\r\n*/\r\n\r\nconst testToggleTodo = () => {\r\n\r\n  const todoBefore = {\r\n    id:0,\r\n    text: 'Learn Redux',\r\n    completed: false\r\n  };\r\n\r\n    const todoAfter = {\r\n    id:0,\r\n    text: 'Learn Redux',\r\n    completed: true\r\n  };\r\n\r\n  deepFreeze(todoBefore);\r\n  expect(toggleTodo(todoBefore)).toEqual(todoAfter);\r\n\r\n};\r\n\r\ntestToggleTodo();\r\n\r\nconsole.log('All tests Passed.');\r\n\r\n```\r\n\r\nYou can use `Object.assign()` or ...spread operator to mutate Object.\r\n\r\nWhen using `Object.assign()` use a Polyfill to support evergreen browsers.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}
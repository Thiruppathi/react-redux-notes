{"name":"React-redux-notes","tagline":"Study notes of React-Redux from DanAbramov's Talk","body":"# react-redux-notes\r\nStudy notes of React-Redux.\r\n\r\n## 1. The Single Immutable State Tree\r\nThe first principle of Redux is, the entire application's state is managed through a Single JS Object i.e, **'Single Immutable State Tree'**.\r\n\r\nEverything that changes within the application, including the data & the UI State are contained in single JS Object called 'State Tree'.\r\n\r\nIn more complex applications, more state to keep track of. You can track back the state changes from this State tree.\r\n\r\n## 2. Describing State changes with Actions\r\nThe state-tree is read-only.\r\n\r\nWhenever you want to change the state, you need to dispatch an action.\r\n\r\nAn action is a plain js object which defines the change.\r\n\r\nJust like the State is the minimial representation of data in the app, The Action is the minimal representation of the change to the data.\r\n\r\nThe structure of Action object is up to you, the only requirement is that it has a\r\n\r\n`type` property, which is not undefined.\r\n\r\nIts suggested that to use \"String\" as it's serializable.\r\n\r\nDifferent type of apps have Different type of actions. We don't need additional information for passing the action.\r\n\r\n## 3. Pure & Impure Function\r\nIts important to understand the pure & impure functions.\r\n\r\n### Pure Functions\r\nPure Functions are the functions whose return values are solely dependent on the parameters passed on to the functions. Pure Functions doesn't have any observable side effects such as network/database calls.\r\n\r\nYou can be confident that if you call a pure function, for the  same arguments, your are gonna get the same return values always. Results are predictable.\r\n\r\n```\r\nfunction square(x) {\r\n  return x * x;\r\n}\r\n```\r\n\r\nPure functions doesn't modify the values to passed to them. In the following example, the items array is not modified, instead it returns a new Array, by using items.map();\r\n\r\n```\r\nfunction squareAll(items) {\r\n  return items.map(square);\r\n}\r\n```\r\n\r\n### Impure Functions\r\nOn the opposite,  Impure functions, they may have side effects; they may call db, make network requests, they may override the values to passed to them.\r\n\r\n```\r\nfunction square(x) {\r\n  updateXinDB(x);\r\n  return x * x;\r\n}\r\n\r\nfunction squareAll(items) {\r\n  for(let i=0; i<items.length; i++ ){\r\n    items[i] = square(items[i]);\r\n  }\r\n}\r\n```\r\n\r\n## 4. The Reducer Function\r\nThe UI/View layer is more predictable, when it is just described as pure functions of the application state. This approach was pioneered by React.\r\n\r\nRedux complements this approach with another idea.\r\n\r\nThe state mutation in your app should be  described as pure function.\r\n\r\nThat takes `PreviousState` , `ActionBeingDispatched` and return the `NextState` of your application.\r\n\r\nIn any redux application, there is one particular function that takes the  state of the whole application and the action being dispatched and return the next state of the whole application.\r\n\r\nIt is important that it doesn't modify the state to given to it. It has to be pure and should only return the next state.(new object)\r\n\r\nThis function is called **'Reducer'** Function.\r\n\r\n## 5. Writing a counter Reducer with Tests\r\nWe are going to write a Simple Counter example using Reducer.\r\n\r\n```\r\nfunction counter(state, action) {\r\n  return state;\r\n}\r\n```\r\n\r\nLets write some test cases using `expect` framework\r\n\r\n```\r\n  expect(\r\n    counter(0, {type:'INCREMENT'})\r\n  ).toEqual(1);\r\n\r\n  expect(\r\n      counter(1, {type:'INCREMENT'})\r\n  ).toEqual(2);\r\n\r\n  expect(\r\n      counter(2, {type:'DECREMENT'})\r\n  ).toEqual(1);\r\n\r\n  expect(\r\n        counter(1, {type:'DECREMENT'})\r\n  ).toEqual(0);\r\n\r\n  console.log('Tests Passed');\r\n```\r\n\r\nThese test gonna fail, as we've not implemented the Reducer completely.\r\n\r\nLets do that now. Based on the `action.type` we need to change the state.\r\n\r\n```\r\nfunction counter(state,action) {\r\n  if(action.type==='INCREMENT') {\r\n    return state + 1;\r\n  } else if(action.type==='DECREMENT') {\r\n    return state - 1;\r\n  }\r\n}\r\n```\r\n\r\nNow the tests are passing. However if we pass an action which is not understood by the reducer, we need to maintain the current state.\r\n\r\n```\r\nexpect(\r\n      counter(1, {type:'SOMETHING_ELSE'})\r\n).toEqual(0);\r\n```\r\n\r\nLet us change the reducer to handle this.\r\n\r\n```\r\nfunction counter(state,action) {\r\n  if(action.type==='INCREMENT') {\r\n    return state + 1;\r\n  } else if(action.type==='DECREMENT') {\r\n    return state - 1;\r\n  } else {\r\n    return state;\r\n  }\r\n}\r\n```\r\n\r\nThe initial state of the application can be handled as follows\r\n\r\n```\r\nexpect(\r\n      counter(undefined, {})\r\n).toEqual(0);\r\n```\r\n\r\nThis will fail the test cases.\r\n\r\n```\r\nfunction counter(state,action) {\r\nif(typeof state ==== 'undefined') {\r\n  return 0;\r\n}\r\n\r\n  if(action.type==='INCREMENT') {\r\n    return state + 1;\r\n  } else if(action.type==='DECREMENT') {\r\n    return state - 1;\r\n  } else {\r\n    return state;\r\n  }\r\n}\r\n```\r\n\r\nLet us change the schematic and use ES6 syntax.\r\n\r\n```\r\nconst counter = (state = 0,action) => {\r\n\r\nswitch(action.type) {\r\n  case 'INCREMENT' :\r\n    return state + 1;\r\n  case 'DECREMENT':\r\n    return state - 1;\r\n  default:\r\n  return state;\r\n}\r\n}\r\n```\r\n\r\n## 6.Store Methods - getState(), dispatch() and subscribe()\r\nThe Store binds together the 3 principles of Redux.\r\n- It holds the current application state object.\r\n- It lets you dispatch actions.\r\n- When they are created, you need to specify the reducer to tell how the state is updated by the Actions.\r\n\r\nThe Store has 3 important methods. react-design-diagram\r\n1. store.getState();\r\n2. store.dispatch({type:'INCREMENT'});\r\n3. store.subscribe() - It lets you register a callback, that redux Store will call it whenever a Action is dispatched.\r\n4. So that you can update your UI of your application.\r\n\r\n[JSBin of the Demo](http://jsbin.com/nujole/2/edit?html,js,console,output)\r\n\r\n## 7. Implementing Store from Scratch\r\nIn the previous step, we looked at how to implement a simple counter example by using createStore() provided by Redux.\r\n\r\nNow we are going to re-implement createStore() provide by Redux from scratch.\r\n\r\n[JS Bin of Demo](http://jsbin.com/cewote/edit?html,js,output) Instead of using Redux createStore() as follows,\r\n\r\n```\r\nconst {createStore} = Redux;\r\n```\r\n\r\nWe gonna create the createStore as follows.\r\n\r\n```\r\nconst createStore = (reducer) => {\r\n  let state;\r\n  let listeners = [];\r\n\r\n  const getState = () => state;\r\n\r\n  const dispatch = (action) => {\r\n    state = reducer(state, action);\r\n    listeners.forEach(listener => listener());\r\n  };\r\n\r\n  const subscribe = (listener) => {\r\n    listeners.push(listener);\r\n    return () => {\r\n      listeners = listeners.filter(l => l !== listener);\r\n    };\r\n  };\r\n\r\n  dispatch({});\r\n\r\n  return {getState, dispatch, subscribe};\r\n\r\n};\r\n```\r\n\r\n## 8. React Counter example\r\nLets use React components to render the Counter value.\r\n\r\n[JS Bin Demo](http://jsbin.com/razemo/edit?html,js,console,output)\r\n\r\n## 9. Avoiding Array Mutation using concat, slice & ...spread\r\n[JS Bin Demo](http://jsbin.com/zucogi)\r\n<script src=\"https://gist.github.com/anonymous/2b9775562a5c4d01abd7.js\"></script>\r\n\r\n## 10. Avoid Object Mutation with Object.assign() and ...spread\r\n[JS Bin Demo](http://jsbin.com/zoveqo/3/edit)\r\n\r\n```\r\n\r\nconst toggleTodo = (todo) => {\r\n  return {\r\n    ...todo,\r\n    completed: !todo.completed\r\n  };\r\n};\r\n\r\n/*\r\nconst toggleTodo = (todo) => {\r\n  return Object.assign({}, todo, {\r\n    completed: !todo.completed\r\n  });\r\n};\r\n*/\r\n\r\nconst testToggleTodo = () => {\r\n\r\n  const todoBefore = {\r\n    id:0,\r\n    text: 'Learn Redux',\r\n    completed: false\r\n  };\r\n\r\n    const todoAfter = {\r\n    id:0,\r\n    text: 'Learn Redux',\r\n    completed: true\r\n  };\r\n\r\n  deepFreeze(todoBefore);\r\n  expect(toggleTodo(todoBefore)).toEqual(todoAfter);\r\n\r\n};\r\n\r\ntestToggleTodo();\r\n\r\nconsole.log('All tests Passed.');\r\n```\r\n\r\nYou can use `Object.assign()` or ...spread operator to mutate Object.\r\n\r\nWhen using `Object.assign()` use a Polyfill to support evergreen browsers.\r\n\r\n## 11. Writing a ToDo List Reducer ( Adding a ToDo)\r\n[JS Bin Demo](http://jsbin.com/tenizo/edit?js,console)\r\n\r\n```\r\nconst todos = (state=[],action) => {\r\n  switch(action.type) {\r\n    case 'ADD_TODO':\r\n      return[\r\n        ...state,\r\n        {\r\n          id: action.id,\r\n          text: action.text,\r\n          completed: false\r\n        }\r\n      ];\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n\r\nconst testAddTodo = () => {\r\n  const stateBefore = [];\r\n  const action = {\r\n    type: 'ADD_TODO',\r\n    id: 0,\r\n    text: 'Learn Redux'\r\n  };\r\n\r\n  const stateAfter = [\r\n    {\r\n      id:0,\r\n      text:'Learn Redux',\r\n      completed: false\r\n    }\r\n  ];\r\n\r\n  deepFreeze(stateBefore);\r\n    deepFreeze(action);\r\n\r\n  expect(\r\n    todos(stateBefore, action)\r\n  ).toEqual(stateAfter);\r\n};\r\n\r\ntestAddTodo();\r\nconsole.log('All tests passed.');\r\n```\r\n\r\n## 12. Writing a Todo List Reducer - Toggling a Todo\r\n[JS Bin Demo](http://jsbin.com/moyepe/edit?js,console)\r\n\r\n```\r\nconst todos = (state=[],action) => {\r\n  switch(action.type) {\r\n    case 'ADD_TODO':\r\n      return[\r\n        ...state,\r\n        {\r\n          id: action.id,\r\n          text: action.text,\r\n          completed: false\r\n        }\r\n      ];\r\n        case 'TOGGLE_TODO':\r\n            return state.map(todo => {\r\n                if(todo.id !== action.id) {\r\n                    return todo;\r\n                }\r\n\r\n                return {...todo, completed: !todo.completed };\r\n            });\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n\r\n\r\n\r\nconst testAddTodo = () => {\r\n  const stateBefore = [];\r\n  const action = {\r\n    type: 'ADD_TODO',\r\n    id: 0,\r\n    text: 'Learn Redux'\r\n  };\r\n\r\n  const stateAfter = [\r\n    {\r\n      id:0,\r\n      text:'Learn Redux',\r\n      completed: false\r\n    }\r\n  ];\r\n\r\n  deepFreeze(stateBefore);\r\n    deepFreeze(action);\r\n\r\n  expect(\r\n    todos(stateBefore, action)\r\n  ).toEqual(stateAfter);\r\n};\r\n\r\nconst testToggleTodo = () => {\r\n  const stateBefore = [\r\n    {\r\n      id:0,\r\n      text:'Learn Redux',\r\n      completed: false\r\n    },\r\n        {\r\n      id:1,\r\n      text:'Learn NodeJS',\r\n      completed: false\r\n    }\r\n  ];  \r\n  const action = {\r\n    type: 'TOGGLE_TODO',\r\n    id: 1\r\n  };\r\n    const stateAfter = [\r\n    {\r\n      id:0,\r\n      text:'Learn Redux',\r\n      completed: false\r\n    },\r\n        {\r\n      id:1,\r\n      text:'Learn NodeJS',\r\n      completed: true\r\n    }\r\n  ];  \r\n\r\n\r\n  deepFreeze(stateBefore);\r\n    deepFreeze(action);\r\n\r\n  expect(\r\n    todos(stateBefore, action)\r\n  ).toEqual(stateAfter);\r\n};\r\n\r\ntestAddTodo();\r\ntestToggleTodo();\r\nconsole.log('All tests passed.')\r\n```\r\n\r\n## 13. Reducer Composition with Arrays\r\n[JS Bin Demo](http://jsbin.com/mumaya/edit?js,console)\r\n\r\n```\r\nconst todo = (state, action) => {\r\n    switch(action.type) {\r\n        case 'ADD_TODO':\r\n            return {\r\n                id: action.id,\r\n                text: action.text,\r\n                completed: false\r\n            };\r\n        case 'TOGGLE_TODO':\r\n            if(state.id !== action.id) {\r\n                return state;\r\n            }\r\n\r\n            return {\r\n                ...state,\r\n                completed: !state.completed\r\n            };\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\n\r\nconst todos = (state=[],action) => {\r\n  switch(action.type) {\r\n    case 'ADD_TODO':\r\n      return[\r\n        ...state,\r\n        todo(undefined, action)\r\n      ];\r\n        case 'TOGGLE_TODO':\r\n            return state.map(t => todo(t,action));\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n```\r\n\r\n## 14. Reducer Composition with Objects\r\n[JS Bin Demo](http://jsbin.com/wivutu/edit?js,console)\r\n\r\n```\r\nconst todo = (state, action) => {\r\n    switch(action.type) {\r\n        case 'ADD_TODO':\r\n            return {\r\n                id: action.id,\r\n                text: action.text,\r\n                completed: false\r\n            };\r\n        case 'TOGGLE_TODO':\r\n            if(state.id !== action.id) {\r\n                return state;\r\n            }\r\n\r\n            return {\r\n                ...state,\r\n                completed: !state.completed\r\n            };\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\n\r\nconst todos = (state=[],action) => {\r\n  switch(action.type) {\r\n    case 'ADD_TODO':\r\n      return[\r\n        ...state,\r\n        todo(undefined, action)\r\n      ];\r\n        case 'TOGGLE_TODO':\r\n            return state.map(t => todo(t,action));\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n\r\n\r\nconst visibilityFilter = (\r\n  state = 'SHOW_ALL',\r\n  action\r\n  ) => {\r\n    switch(action.type) {\r\n        case 'SET_VISIBILITY_FILTER':\r\n            return action.filter;\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\n\r\nconst todoApp = (state ={}, action) => {\r\n    return {\r\n        todos: todo(state.todos, action),\r\n        visibilityFilter: visibilityFilter(state.visibilityFilter, action)\r\n    };\r\n};\r\n\r\n\r\nconst {createStore} = Redux;\r\nconst store = createStore(todoApp);\r\n```\r\n\r\n## 15. Reducer Composition with combineReducers()\r\n[JS Bin Demo](http://jsbin.com/puqalo/edit?js,console)\r\n\r\n```\r\nconst todoApp = (state ={}, action) => {\r\n    return {\r\n        todos: todo(state.todos, action),\r\n        visibilityFilter: visibilityFilter(state.visibilityFilter, action)\r\n    };\r\n};\r\n```\r\n\r\nThis pattern is so common in most of the Redux-Apps.\r\n\r\nThats why Redux provides a function called `{combineReducers}`\r\n\r\n```\r\nconst {combineReducers} = Redux;\r\n\r\nconst todoApp = combineReducers ({\r\n  todos: todos,\r\n  visibilityFilter : visibilityFilter\r\n  });\r\n```\r\n\r\nThe Keys of the object that configured in the combineReducers denotes the fields  of the state object.\r\n\r\nThe Values of the object that configured in the combineReducers denotes the reducers it should call to update the corresponding state fields.\r\n\r\nLet's establish a useful convention.  I'll always name my Reducers after the state keys they manage.\r\n\r\nThanks to ES6 Object literal shorthand notation.\r\n\r\n```\r\nconst {combineReducers} = Redux;\r\n\r\nconst todoApp = combineReducers ({ todos,  visibilityFilter  });\r\n```\r\n\r\n## 16. Implementing combineReducers() from Scratch\r\n[JS Bin Demo](http://jsbin.com/tazuzi/edit?js,console)\r\n\r\nTo gain deeper understanding of combineReducers works, let us implement it from Scratch.\r\n\r\n```\r\nconst combineReducers = (reducers) => {\r\n  return (state = {}, action) => {\r\n    return Object.keys(reducers).reduce(\r\n      (nextState, key) => {\r\n        nextState[key] = reducers[key](\r\n          state[key],\r\n          action\r\n        );\r\n        return nextState;\r\n      }, {}\r\n    );\r\n  };\r\n};\r\n```\r\n\r\n## 17. React ToDo List Example (Adding a ToDo)\r\n[JS Bin Demo](http://jsbin.com/nimeqe/edit?html,js,output)\r\n\r\n```\r\n\r\nconst { Component } = React;\r\n\r\nlet nextTodoId = 0;\r\n\r\nclass TodoApp extends Component {\r\n    render() {\r\n        return (\r\n          <div>\r\n            <input ref={ node => {\r\n            this.input = node;\r\n            }} />\r\n              <button onClick={()=> {\r\n                store.dispatch({\r\n                        type: 'ADD_TODO',\r\n                        text: this.input.value,\r\n                        id: nextTodoId++\r\n                    });\r\n            this.input.value = '';\r\n        }}>\r\n      Add Todo\r\n        </button>\r\n        <ul>\r\n            {this.props.todos.map(todo =>\r\n             <li key = {todo.id}>\r\n              {todo.text}\r\n            </li>\r\n             )}\r\n        </ul>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nconst render = () => {\r\n    ReactDOM.render(\r\n    <TodoApp\r\n        todos={store.getState().todos}\r\n  />,\r\n    document.getElementById('root')\r\n    );\r\n};\r\n\r\nstore.subscribe(render);\r\nrender();\r\n```\r\n\r\n## 18. React ToDo List Example (Toggling a ToDo)\r\n[JS Bin Demo](http://jsbin.com/kozaba/edit?html,js,output)\r\n\r\n```\r\n<ul>\r\n  {this.props.todos.map(todo =>\r\n   <li  key = {todo.id}\r\n        onClick={()=>{\r\n                 store.dispatch({\r\n                 type: 'TOGGLE_TODO',\r\n                 id: todo.id\r\n                });\r\n        }}\r\n        style = {{\r\n          textDecoration: todo.completed ? 'line-through' : 'none'\r\n                }}>\r\n  {todo.text}\r\n  </li>\r\n   )}\r\n</ul>\r\n```\r\n\r\n## 19. React ToDo List Example (Filtering a ToDo)\r\n\r\n[JS Bin Demo](http://jsbin.com/zedafi/edit?html,js,output)\r\n\r\n```\r\nconst FilterLink = ({\r\n  filter,\r\n  currentFilter,\r\n  children\r\n}) => {\r\n  if (filter === currentFilter) {\r\n    return <span > {\r\n      children\r\n    } < /span>;\r\n  }\r\n  return ( < a href = '#'\r\n    onClick = {\r\n      e => {\r\n        e.preventDefault();\r\n        store.dispatch({\r\n          type: 'SET_VISIBILITY_FILTER',\r\n          filter\r\n        });\r\n      }\r\n    } > {\r\n      children\r\n    } < /a>\r\n  );\r\n\r\n};\r\n```\r\n\r\n```\r\nconst getVisibleTodos = (\r\n  todos, filter\r\n) => {\r\n  switch (filter) {\r\n    case 'SHOW_ALL':\r\n      return todos;\r\n    case 'SHOW_COMPLETED':\r\n      return todos.filter(t => t.completed);\r\n    case 'SHOW_ACTIVE':\r\n      return todos.filter(t => !t.completed);\r\n  }\r\n};\r\n```\r\n\r\n```\r\n< p >\r\n  Show: {\r\n    ' '\r\n  } < FilterLink filter = 'SHOW_ALL'\r\ncurrentFilter = {\r\n  visibilityFilter\r\n} > All < /FilterLink> {\r\n' '\r\n} < FilterLink filter = 'SHOW_ACTIVE'\r\ncurrentFilter = {\r\n  visibilityFilter\r\n} > Active < /FilterLink> {\r\n' '\r\n} < FilterLink filter = 'SHOW_COMPLETED'\r\ncurrentFilter = {\r\n  visibilityFilter\r\n} > Completed < /FilterLink> < /p >\r\n\r\n```\r\n\r\n\r\n## 20. Extracting Presentational components (ToDo, ToDo List)\r\n\r\n[JS Bin Demo](http://jsbin.com/nefefi/edit?js,output)\r\n\r\nLet's Extract the ToDo Component.\r\n\r\n```\r\nconst Todo = ({ onClick,completed, text }) => (\r\n\t<li\r\n\t  onClick = {onClick}\r\n    style = {{textDecoration: completed ? 'line-through' : 'none'}}>\r\n\t    {text}\r\n\t</li>\r\n);\r\n```\r\n\r\nNow, Extract the TodoList Component.\r\n\r\n```\r\nconst TodoList = ({\ttodos,\tonTodoClick }) => (\r\n    <ul>\r\n      {todos.map(todo =>\r\n\t\t\t\t  <Todo\r\n\t\t\t\t    key={todo.id}\r\n\t          {...todo}\r\n\t          onClick={() => onTodoClick(todo.id)}\r\n          />\r\n      )}\r\n    </ul>\r\n);\r\n\r\n```\r\n\r\nNow, in the render method, repalce the `<ul>` with our extracted component.\r\n\r\n```\r\n<TodoList\r\n  todos = {visibleTodos}\r\n   onTodoClick = {id =>\r\n      store.dispatch({\r\n        type: 'TOGGLE_TODO',\r\n        id\r\n      })\r\n  } />\r\n```\r\n\r\n\r\n## 21. Extracting Presentational components (Add ToDo, Footer, Filter Link)\r\n\r\n[JS Bin Demo](http://jsbin.com/tedoqi/edit?html,js,output)\r\n\r\nAdd ToDo\r\n\r\n```\r\nconst AddTodo = ({onAddClick}) => {\r\n\tlet input;\r\n\r\n\treturn (\r\n      <div>\r\n        <input ref = { node => {input = node;}}/>\r\n        <button onClick = { () => {\r\n\t\t\t\t\t\t\tonAddClick(input.value);\r\n\t\t\t\t\t\t\tinput.value = '';\r\n\t\t\t\t\t}}>\r\n\t\t\t\t\t\tAdd Todo\r\n        </button>\r\n\t\t\t</div>\r\n\t\t\t);\r\n};\r\n```\r\n\r\nFooter\r\n\r\n```\r\nconst Footer = ({visibilityFilter, onFilterClick}) => (\r\n\t\t\t\t<p>\r\n           Show :\r\n             {' '}\r\n             <FilterLink filter = 'SHOW_ALL'  currentFilter = {visibilityFilter} onClick={onFilterClick}>\r\n\t\t\t\t\t\t\t All\r\n\t\t\t\t\t\t </FilterLink>\r\n             {' ,  '}\r\n             <FilterLink filter = 'SHOW_ACTIVE'  currentFilter = {visibilityFilter} onClick={onFilterClick}>\r\n\t\t\t\t\t\t\t Active\r\n\t\t\t\t\t\t </FilterLink>\r\n             {' ,  '}\r\n             <FilterLink filter = 'SHOW_COMPLETED'  currentFilter = {visibilityFilter} onClick={onFilterClick}>\r\n\t\t\t\t\t\t\t Completed\r\n\t\t\t\t\t\t </FilterLink>\r\n        </p>\r\n);\r\n```\r\n\r\nFilter Link\r\n\r\n```\r\nconst FilterLink = ({ filter, currentFilter, children, onClick }) => {\r\n\r\n\tif (filter === currentFilter) {\r\n    return <span> {children} </span>;\r\n\t}\r\n\r\n\treturn (\r\n\t\t<a\r\n        href = '#'\r\n        onClick = { e => {\r\n                    e.preventDefault();\r\n                    onClick(filter)\r\n                  }\r\n        }>\r\n      {children}\r\n    </a>\r\n  );\r\n};\r\n```\r\n\r\nThe final ToDoApp component\r\n\r\n```\r\nconst TodoApp = ({todos, visibilityFilter}) => (\r\n      <div>\r\n\r\n\t\t\t<AddTodo\r\n\t\t\t      onAddClick={text=>\r\n\t\t\t        store.dispatch({\r\n\t\t\t          type:'ADD_TODO',\r\n\t\t\t          id:nextTodoId++,\r\n\t\t\t          text\r\n          \t\t})\r\n\t\t\t      }\r\n\t    />\r\n\r\n        <TodoList\r\n          todos = {getVisibleTodos(todos, visibilityFilter)}\r\n      \t\t onTodoClick = {id =>\r\n              store.dispatch({\r\n                type: 'TOGGLE_TODO',\r\n                id\r\n              })\r\n          } />\r\n\r\n\t\t\t\t\t<Footer\r\n\t\t\t\t\t  visibilityFilter={visibilityFilter}\r\n\t\t\t\t\t\tonFilterClick={filter =>\r\n\t\t\t\t\t\t  store.dispatch({\r\n\t\t\t\t\t\t\t\t\ttype: 'SET_VISIBILITY_FILTER',\r\n\t\t\t\t\t\t\t\t\tfilter\r\n\t\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t/>\r\n      </div>\r\n    );\r\n```\r\n\r\nSeparation of Presentational Component, decouples the rendering from REDUX.\r\n\r\nThis has a downside of passing too many properties to the component, which can be resolved using **Container Components**.\r\n\r\n\r\n## 22. Extracting Container components (Filter Link)\r\n\r\n[JS Bin Demo](http://jsbin.com/woloqo/edit?html,js,output)\r\n\r\nIn previous step, **Footer** component passes down `visibilityFilter` and `onFilterClick` to the **FilterLink** component, even though **Footer** doesn't use this properties directly.\r\n\r\nIn this way, it breaks encapsulation where the **ParentComponent** needs to know too much about the **ChildComponent**.\r\n\r\nThats why we need to extract the **Container Components**, just like the way we extracted **Presentational Components**.\r\n\r\nLet's start refactoring with the **Footer** component by removing the properties `visibilityFilter` and `onFilterClick`.\r\n\r\nIn from ToDoApp Component,\r\n```\r\n<Footer\t/>\r\n ```\r\n\r\nAnd from the Footer Component\r\n\r\n```\r\nconst Footer = () => (\r\n\t\t\t\t<p>\r\n           Show :\r\n             {' '}\r\n             <FilterLink filter = 'SHOW_ALL'>All</FilterLink>\r\n             {' ,  '}\r\n             <FilterLink filter = 'SHOW_ACTIVE'>Active</FilterLink>\r\n             {' ,  '}\r\n             <FilterLink filter = 'SHOW_COMPLETED'>Completed</FilterLink>\r\n        </p>\r\n);\r\n```\r\n\r\nThis may seem like the same component before extracting to **Presentational Component**.\r\n\r\nBut what we are going to do is bit Different.\r\n\r\n\r\nLet's have a look at **Filter** Component.\r\n```\r\nconst FilterLink = ({ filter, currentFilter, children, onClick }) => {\r\n\r\n\tif (filter === currentFilter) {\r\n    return <span> {children} </span>;\r\n\t}\r\n\r\n\treturn (\r\n\t\t<a\r\n        href = '#'\r\n        onClick = { e => {\r\n                    e.preventDefault();\r\n                    onClick(filter)\r\n                  }\r\n        }>\r\n      {children}\r\n    </a>\r\n  );\r\n};\r\n```\r\n\r\nThe FilterLink\r\n - doesn't specify the behaviour for Clicking on the link.\r\n - It also needs the current filter to tell whether its active or not to render.\r\n\r\nHonestly, this is not a **Presentational Component**, because its not separable with its behaviour.\r\n\r\nThe only reasonable  reaction to clicking on it is to set visibilityFilter by dispatching an action.\r\n\r\nThis is why we should change it different **Presentational Component** as follows.\r\n\r\n```\r\nconst Link = ({ active, children, onClick }) => {\r\n\r\n\tif (active) {\r\n    return <span> {children} </span>;\r\n\t}\r\n\r\n\treturn (\r\n\t\t<a\r\n        href = '#'\r\n        onClick = { e => {\r\n\t\t      e.preventDefault();\r\n        \tonClick();\r\n        }}\r\n\t\t>\r\n\t\t\t{children}\r\n    </a>\r\n  );\r\n};\r\n```\r\n\r\nThe **Link** component doesn't know anything about filtering.\r\n\r\n- It only accepts `active` property\r\n- Handles click through `onClick()`\r\n\r\nLet us create another component **FilterLink** as a container that uses **Link** to render it.\r\nIts gonna render the **Link** from the current data from `store`.\r\n\r\nIts going to\r\n- read the props from the component props.\r\n- read the state from redux's store state\r\n\r\n\r\n```\r\nclass FilterLink extends Component {\r\n\r\n\trender() {\r\n\t\tconst props = this.props;\r\n\t\tconst state = store.getState();\r\n\t}\r\n}\r\n\r\n```\r\nAs a **Container Component** the **FilterLink** doesn't have its own mark up.\r\nIt delegates the rendering through the **Link Presentational Component**.\r\n\r\nIn this case it calculates it's `active` props, by comparing with the redux store state's `visibilityFilter`.\r\n\r\nThe `filter` props is the one we passed from the **Footer** component.\r\nThe `visibilityFilter` corresponds to the currently chosen `visibilityFilter`.\r\n\r\nI these 2 filters matches, then we make the link to appear active.\r\n\r\n```\r\n<Link  \r\n    active = { props.filter === state.visibilityFilter } >\r\n</Link>\r\n```\r\n\r\nThe Container Component also needs to define the  **behaviour**.\r\n\r\nIn this case, the **FilterLink** specifies when this particular link is clicked,\r\n- dispatch an `action` with the type `SET_VISIBILITY_FILTER`\r\n- take the `filter` value from the props\r\n\r\nThe filter link may contain children which is used as content of the **Link**\r\n\r\n```\r\n<Link\r\n  active = { props.filter === state.visibilityFilter }\r\n  onClick={() =>\r\n    store.dispatch({\r\n      type: 'SET_VISIBILITY_FILTER',\r\n      filter: props.filter\r\n    })\r\n  }>\r\n  {props.children}\r\n</Link>\r\n```\r\n\r\nreturn this `Link` markup and the `FilterComponent` becomes like this.\r\n\r\n\r\n```\r\nclass FilterLink extends Component {\r\n\r\n render() {\r\n   const props = this.props;\r\n   const state = store.getState();\r\n\r\n   return (\r\n     <Link\r\n       active = { props.filter === state.visibilityFilter }\r\n       onClick={() =>\r\n         store.dispatch({\r\n           type: 'SET_VISIBILITY_FILTER',\r\n           filter: props.filter\r\n         })\r\n       }\r\n     > {props.children}\r\n     </Link>\r\n   );\r\n }\r\n}\r\n\r\n```\r\n\r\nThere is a small problem with the implementation of **FilterLink**.\r\nInside the `render()` it reads the current state of the ReduxStore, but it is not subscribed to the Store.\r\n\r\nSo if the ParentComponent doesn't updated when the store is updated,\r\nits going to render the child value.\r\n\r\nCurrently we re-render the whole application when the state changes, which is not efficient.\r\n\r\nSo in future, we will move subscription to the store to the LifeCycle methods of **Container Component**.\r\n\r\nReact provides a special `forceUpdate()` method on the component instances.\r\n\r\nTo force the re-rendering. And we are going to use it inside `store.subscribe()` ,\r\nso that whenever the store's state changes we can forceUpdate the **Container Component**\r\n\r\n```\r\ncomponentDidMount() {\r\n  store.subscribe(()=>\r\n    this.forceUpdate()\r\n  );\r\n}\r\n```\r\n\r\nWe did the `forceUpdate` inside `componentDidMount()`. We need to `unsubscribe` inside `componentWillUnMount()`\r\n\r\n```\r\ncomponentWillUnMount() {\r\n  this.unsubscribe();\r\n}\r\n\r\n```\r\n\r\nReact doesn't provide `unsubscribe()` . Its a return value from `store.subscribe()`.\r\n\r\n```\r\ncomponentDidMount() {\r\n  this.unsubscribe = store.subscribe(()=>\r\n    this.forceUpdate()\r\n  );\r\n}\r\n\r\ncomponentWillUnMount() {\r\n  this.unsubscribe();\r\n}\r\n```\r\n\r\nSo our `FilterLink` becomes like this.\r\n\r\n```\r\nclass FilterLink extends Component {\r\n\r\n\tcomponentDidMount() {\r\n\t\tthis.unsubscribe = store.subscribe(()=>\r\n\t\t\tthis.forceUpdate()\r\n\t\t);\r\n\t}\r\n\r\n\tcomponentWillUnMount() {\r\n\t\tthis.unsubscribe();\r\n\t}\r\n\r\n\r\n\trender() {\r\n\t\tconst props = this.props;\r\n\t\tconst state = store.getState();\r\n\r\n\t\treturn (\r\n\t\t  <Link\r\n\t\t\t  active = {\r\n\t\t\t    props.filter === state.visibilityFilter\r\n\t\t\t  }\r\n\t\t\t  onClick={() =>\r\n\t\t\t\t  store.dispatch({\r\n\t\t\t      type: 'SET_VISIBILITY_FILTER',\r\n\t\t\t      filter: props.filter\r\n  \t\t    })\r\n    \t  }\r\n\t    > {props.children}\r\n\t\t\t</Link>\r\n\t\t);\r\n\t}\r\n}\r\n\r\n```\r\n\r\nThus, the **Link** Component only takes care of the *appearance* based on `active` props. It doesn't know about the *behaviour*\r\nThe **FilterLink**  is a **Container Component** which provides *data* and *behaviour* to the **Presentational Component (Link)** .\r\n\r\nWhen it mounts, it subscribes to the store, so it independently re-renders whenever the store state's changes.\r\nInstead of providing its own DOM Tree, it delegates the rendering to the **Presentational Component (Link)**.\r\n\r\nIt's only job is to calculate the props based on the **FilterLink**'s own props and the CurrentState of the Redux Store.\r\n\r\nAnd it also specifies the callback that are going to dispatch the action to the Store.\r\nAfter action is dispatched, the store will remember the new state returned by the Reducer, and it will call every Subscriber to the store.\r\n\r\nIn this case, every **FilterLink** Component instance is subscribed to the store, so they will all have their `forceUpdate()` called on them.\r\nAnd they will re-render according to the Current Store State.\r\n\r\n**FilterLink** is self sufficient that it can be used in any component, with out needing to pass any props to it.\r\n\r\nThis makes the entire **Footer** Component simple and decoupled from the behaviour.\r\n\r\n\r\n## 23. Extracting Container Component (Visible TodoList, AddTodo)\r\n\r\n[JS Bin Demo](http://jsbin.com/yasuca/edit?html,js,console,output)\r\n\r\nLets start with extracting Container Component from **TodoList** to make it as a Presentational Component.\r\n\r\n```\r\n<TodoList\r\n  todos = {getVisibleTodos(todos, visibilityFilter)}\r\n   onTodoClick = {id =>\r\n      store.dispatch({\r\n        type: 'TOGGLE_TODO',\r\n        id\r\n      })\r\n  } />\r\n```\r\n\r\nI want to encapsulate currently visible todos, into a separate **ContainerComponent** which connects to the Redux Store.\r\n\r\n```\r\nclass VisibleTodoList extends Component {\r\n\r\n\tcomponentDidMount() {\r\n\t\tthis.unsubscribe = store.subscribe(()=>\r\n\t\t\tthis.forceUpdate()\r\n\t\t);\r\n\t}\r\n\r\n\tcomponentWillUnMount() {\r\n\t\tthis.unsubscribe();\r\n\t}\r\n\r\n  render() {\r\n    const props = this.props;\r\n    const state = store.getState();\r\n\r\n\t\treturn(\r\n    <TodoList\r\n      todos={\r\n        getVisibleTodos(\r\n          state.todos,\r\n          state.visibilityFilter\r\n          )\r\n      }\r\n      onTodoClick={id=>\r\n        store.dispatch({\r\n          type: 'TOGGLE_TODO',\r\n          id\r\n          })\r\n      }\r\n      />\r\n    );\r\n  }\r\n}\r\n```\r\n\r\nWe no longer need to pass the props from the top. Lets update the `TodoApp` component with this newly created `VisibleTodoList` component.\r\n\r\n```\r\nconst TodoApp = ({todos, visibilityFilter}) => (\r\n      <div>\r\n  \t\t\t<AddTodo\r\n  \t\t\t      onAddClick={text=>\r\n  \t\t\t        store.dispatch({\r\n  \t\t\t          type:'ADD_TODO',\r\n  \t\t\t          id:nextTodoId++,\r\n  \t\t\t          text\r\n            \t\t})\r\n  \t\t\t      }\r\n  \t    />\r\n        <VisibleTodoList />\r\n\t\t\t\t<Footer\t/>\r\n      </div>\r\n    );\r\n```\r\n\r\nIn previous section, we made `AddTodo` as a **Presentational Component**. Now let's  put back the behaviour to the `AddToDo`\r\n\r\nThere isn't much behaviour and presentation in this component; in future we may need to extract the presentation based on the complexity.\r\n\r\n```\r\nconst AddTodo = () => {\r\n\tlet input;\r\n\r\n\treturn (\r\n      <div>\r\n        <input ref = { node => {input = node;}}/>\r\n        <button onClick = { () => {\r\n                store.dispatch({\r\n                  type:'ADD_TODO',\r\n                  id:nextTodoId++,\r\n                  text: input.value\r\n                })\r\n\t\t\t\t\t\t\tinput.value = '';\r\n\t\t\t\t\t}}>\r\n\t\t\t\t\t\tAdd Todo\r\n        </button>\r\n\t\t\t</div>\r\n\t\t\t);\r\n};\r\n```\r\nNone of the Container component needs props from State, so we can remove the props of the `TodoApp` Component.\r\nThis makes the Top Level component simpler.\r\n\r\n```\r\nconst TodoApp = () => (\r\n      <div>\r\n  \t\t\t<AddTodo />\r\n        <VisibleTodoList />\r\n\t\t\t\t<Footer\t/>\r\n      </div>\r\n    );\r\n```\r\n\r\nWe can  remove  \r\n- `render()` function which renders the `<TodoApp>` with the current state of the app.\r\n- all the `props` that are related to the `state`\r\n- `store.subscribe(render)`\r\n- `render()`\r\n\r\n\r\nBecause the ContainerComponent are going to Subscribe to the stores themselves.\r\n\r\nSo the following code\r\n\r\n```\r\nconst render = () => {\r\n  ReactDOM.render(\r\n\t\t<TodoApp {...store.getState()}/>,\r\n\t  document.getElementById('root')\r\n  );\r\n};\r\n\r\nstore.subscribe(render);\r\nrender();\r\n\r\n```\r\n\r\nbecomes like this\r\n\r\n```\r\n  ReactDOM.render(\r\n\t\t<TodoApp/>,\r\n\t  document.getElementById('root')\r\n  );\r\n```\r\n\r\nSeparating the Presentational & Container Components is a good practice in most cases.\r\nOnly do this when it truly reduces the complexity of your code base.\r\n\r\nAs a good practice\r\n\r\n- First extract the **Presentational Components**\r\n- If there's too much boilerplate code, passing too many props, then you can extract **ContainerComponent** around them.\r\n\r\n## 24. Passing the Store Down Explicitly via Props\r\n\r\n[JS Bin Demo](http://jsbin.com/copufu/edit?html,js,output)\r\n\r\nManaging store in a single file is not possible for RealTime Apps.\r\n - Single Store Reference makes Testing harder for Container Components. ( You may want a Mock Store for Testing Purpose)\r\n - Server Side Rendering becomes complex, where it has to use a different Store instance based on data.\r\n\r\n\r\nLet us move the store creation code next to `ReactOM.render()`\r\n\r\n```\r\nconst { createStore } = Redux;\r\n\r\nconst store = createStore(todoApp);\r\n\r\nReactDOM.render(\r\n\t<TodoApp />,\r\n\tdocument.getElementById('root')\r\n);\r\n```\r\n\r\nNow lets inject the createStore(todoApp) to the `<TodoApp/>` component as follows\r\n\r\n```\r\nconst { createStore } = Redux;\r\n\r\nReactDOM.render(\r\n\t<TodoApp store={createStore(todoApp)} />,\r\n\tdocument.getElementById('root')\r\n);\r\n```\r\n\r\nUnfortunately we have to pass the store to every component as `props`.\r\n\r\n```\r\nconst TodoApp = ({store}) => (\r\n      <div>\r\n\t\t\t  <AddTodo store={store} />\r\n        <VisibleTodoList store={store} />\r\n\t\t\t\t<Footer\tstore={store} />\r\n      </div>\r\n    );\r\n```\r\n\r\n\r\nIts less effort than passing props to the component; still its inefficient.\r\nWe'll find a better solution to this later; Let us proceed like this to focus on the problem.\r\n\r\nThe problem is that the **Container Component** needs to have the store instance to get the state from the dispatch actions and subscribe to the changes.\r\n\r\nSo we should update the **Container Components** to get the Store from `props`.\r\n\r\nLets start with `VisibleTodoList` by updating the `componentDidMount()` and `render()`\r\n\r\n```\r\ncomponentDidMount() {\r\n  const { store } = this.props;\r\n  this.unsubscribe = store.subscribe(()=>\r\n    this.forceUpdate()\r\n  );\r\n}\r\n```\r\n\r\n```\r\nrender() {\r\n  const props = this.props;\r\n  const { store } = props;\r\n  const state = store.getState();\r\n\r\n  ....\r\n  ....\r\n}\r\n```\r\n\r\nNow the `VisibleTodoList` looks like this.\r\n\r\n```\r\nclass VisibleTodoList extends Component {\r\n\r\n\tcomponentDidMount() {\r\n    const { store } = this.props;\r\n\t\tthis.unsubscribe = store.subscribe(()=>\r\n\t\t\tthis.forceUpdate()\r\n\t\t);\r\n\t}\r\n\r\n\tcomponentWillUnMount() {\r\n\t\tthis.unsubscribe();\r\n\t}\r\n\r\n  render() {\r\n    const props = this.props;\r\n    const { store } = props;\r\n    const state = store.getState();\r\n\r\n\t\treturn(\r\n    <TodoList\r\n      todos={\r\n        getVisibleTodos(\r\n          state.todos,\r\n          state.visibilityFilter\r\n          )\r\n      }\r\n      onTodoClick={id=>\r\n        store.dispatch({\r\n          type: 'TOGGLE_TODO',\r\n          id\r\n          })\r\n      }\r\n      />\r\n    );\r\n  }\r\n}\r\n```\r\n\r\nLet's follow the same steps to update remaining **Container Components**\r\n\r\n**AddTodo**\r\n\r\n```\r\nconst AddTodo = ({ store }) => {\r\n\tlet input;\r\n\r\n\treturn (\r\n      <div>\r\n        <input ref = { node => {input = node;}}/>\r\n        <button onClick = { () => {\r\n                store.dispatch({\r\n                  type:'ADD_TODO',\r\n                  id:nextTodoId++,\r\n                  text: input.value\r\n                })\r\n\t\t\t\t\t\t\tinput.value = '';\r\n\t\t\t\t\t}}>\r\n\t\t\t\t\t\tAdd Todo\r\n        </button>\r\n\t\t\t</div>\r\n\t\t\t);\r\n};\r\n```\r\n\r\n**Footer**\r\n```\r\nconst Footer = ({ store }) => (\r\n\t\t\t\t<p>\r\n           Show :\r\n             {' '}\r\n             <FilterLink filter = 'SHOW_ALL' store={store}>All</FilterLink>\r\n             {' ,  '}\r\n             <FilterLink filter = 'SHOW_ACTIVE' store={store}>Active</FilterLink>\r\n             {' ,  '}\r\n             <FilterLink filter = 'SHOW_COMPLETED' store={store}>Completed</FilterLink>\r\n        </p>\r\n);\r\n```\r\n**FilterLink**\r\n```\r\nclass FilterLink extends Component {\r\n\r\n\tcomponentDidMount() {\r\n    const { store } = this.props;\r\n\t\tthis.unsubscribe = store.subscribe(()=>\r\n\t\t\tthis.forceUpdate()\r\n\t\t);\r\n\t}\r\n\r\n\tcomponentWillUnMount() {\r\n\t\tthis.unsubscribe();\r\n\t}\r\n\r\n\r\n\trender() {\r\n\t\tconst props = this.props;\r\n    const { store } = props;\t\t\r\n\t\tconst state = store.getState();\r\n\r\n\t\treturn (\r\n\t\t  <Link\r\n\t\t\t  active = {\r\n\t\t\t    props.filter === state.visibilityFilter\r\n\t\t\t  }\r\n\t\t\t  onClick={() =>\r\n\t\t\t\t  store.dispatch({\r\n\t\t\t      type: 'SET_VISIBILITY_FILTER',\r\n\t\t\t      filter: props.filter\r\n  \t\t    })\r\n    \t  }\r\n\t    > {props.children}\r\n\t\t\t</Link>\r\n\t\t);\r\n\t}\r\n}\r\n```\r\n\r\nNow all components read the Store from the props, and don't rely on the top level store.\r\n\r\nThis change did not affect the behaviour or the DataFlow of the application.\r\n\r\nThe **ContainerComponent** subscribes to the Store, just like before and updates the state in response to the changes.\r\n\r\nWhat changed is how they access the store. Previously it accesses through top level variable, which doesn't scale much on Real World Applications.\r\n\r\nThat's why we pass down the store as `props`, so that the **ContainerComponents** can subscribe to it.\r\n\r\nIn future example, we'll see how to pass the store down to the **ContainerComponents** implicitly, but without introducing the top level variable.\r\n\r\n\r\n## 25. Passing the Store Down Implicitly via Context\r\n[JS Bin Demo] (http://jsbin.com/yuhusa/edit?html,js,output)\r\n\r\nIn the previous step, we got rid of the top level Store variable and passed it as a `prop` to the component.\r\nWe had to write lot of boilerplate code to pass down the store as `props`;\r\n\r\nThere is another way using the Advanced React feature called **Context**.\r\n\r\nLet us create a new Component called `Provider`.\r\n\r\nFrom its `render()` it just returns whatever it's the child is.\r\nSo we can wrap any Component under `Provider` & its gonna render the Component.\r\n\r\n```\r\nclass Provider extends Component {\r\n  render() {\r\n    return this.props.children;\r\n  }\r\n}\r\n```\r\nI'm going to update the `render()` to\r\n - Render the `<TodoApp store={createStore(todoApp)}/>`  inside the `Provider`.\r\n - Move the `store={createStore(todoApp)} ` to the `<Provider store={createStore(todoApp)}>`\r\n\r\nThe `render()` will look like this.\r\n\r\n```\r\nReactDOM.render(\r\n  <Provider store={createStore(todoApp)} >\r\n\t <TodoApp  />\r\n  </Provider>,\r\n\tdocument.getElementById('root')\r\n);\r\n```\r\n\r\nThe `Provider` Component will use React's advanced Context feature to make the Store available to any Component inside it including grandChildren.\r\n\r\nTo do this, it has to define a special method called `getChildContext()`\r\n\r\n\r\n```\r\nclass Provider extends Component {\r\n  getChildContext() {\r\n    return {\r\n      store: this.props.store\r\n    };\r\n  }\r\n  render() {\r\n    return this.props.children;\r\n  }\r\n}\r\n```\r\n\r\n `store:this.props.store` is the `store` passed through `<Provider store={createStore(todoApp)}>` which will be part of the Context that the `Provider` specifies for its any Children & Grand Children.\r\n\r\nHowever, there is an important condition for the Context to work. i.e.,\r\n\r\n- You've to specify `childContextTypes` on the Component(`Provider`) that defines `getChildContext()`\r\n\r\n```\r\nProvider.childContextTypes = {\r\n  store: React.PropTypes.object\r\n}\r\n```\r\n\r\nThese are just `React.PropTypes` definitions. But unlike `PropTypes`, these `childContextTypes` are essential for the `Context` to be turned on.\r\nIf you don't specify them, no child components will receive this context.\r\n\r\nThe **ContainerComponents** currently access the store through the props. Now you can access through `Context`\r\n\r\n```\r\nclass VisibleTodoList extends Component {\r\n\r\n\tcomponentDidMount() {\r\n    const { store } = this.context;\r\n\t\tthis.unsubscribe = store.subscribe(()=>\r\n\t\t\tthis.forceUpdate()\r\n\t\t);\r\n\t}\r\n\r\n\tcomponentWillUnMount() {\r\n\t\tthis.unsubscribe();\r\n\t}\r\n\r\n  render() {\r\n    const props = this.props;\r\n    const { store } = this.context;\r\n    const state = store.getState();\r\n\r\n\t\treturn(\r\n    <TodoList\r\n      todos={\r\n        getVisibleTodos(\r\n          state.todos,\r\n          state.visibilityFilter\r\n          )\r\n      }\r\n      onTodoClick={id=>\r\n        store.dispatch({\r\n          type: 'TOGGLE_TODO',\r\n          id\r\n          })\r\n      }\r\n      />\r\n    );\r\n  }\r\n}\r\n```\r\n\r\nWe've to specify `contextTypes` for the ContainerComponent.\r\n\r\n```\r\nVisibleTodoList.contextTypes = {\r\n  store: React.PropTypes.object\r\n};\r\n```\r\n\r\nThis is similar to `childContextTypes` but in this case we are specifying which `Context` to receive, not to pass down.\r\nIf we don't define the `contextTypes` then the component will not receive the relevant `Context`\r\n\r\n\r\nWhat about the **FunctionalComponent** Which don't have `this`. e.g. `AddTodo`\r\nIt turns out that it also receives the `Context`, but as the second argument, after the `props`\r\n```\r\nconst AddTodo = (props, { store }) => {\r\n\tlet input;\r\n\r\n\treturn (\r\n      <div>\r\n        <input ref = { node => {input = node;}}/>\r\n        <button onClick = { () => {\r\n                store.dispatch({\r\n                  type:'ADD_TODO',\r\n                  id:nextTodoId++,\r\n                  text: input.value\r\n                })\r\n\t\t\t\t\t\t\tinput.value = '';\r\n\t\t\t\t\t}}>\r\n\t\t\t\t\t\tAdd Todo\r\n        </button>\r\n\t\t\t</div>\r\n\t\t\t);\r\n};\r\n```\r\nJust like the ContainerComponent we need to specify `contextTypes` for this **FunctionalComponent** stating which `Context` it wants to receive.\r\nIn this case, its the `store`.\r\n\r\n```\r\nAddTodo.contextTypes = {\r\n  store: React.PropTypes.object\r\n};\r\n```\r\n\r\n\r\nLet us update `FilterLink` Component now in the same way, to set the Context.\r\n\r\n```\r\nclass FilterLink extends Component {\r\n\r\n\tcomponentDidMount() {\r\n    const { store } = this.context;\r\n\t\tthis.unsubscribe = store.subscribe(()=>\r\n\t\t\tthis.forceUpdate()\r\n\t\t);\r\n\t}\r\n\r\n\tcomponentWillUnMount() {\r\n\t\tthis.unsubscribe();\r\n\t}\r\n\r\n\r\n\trender() {\r\n\t\tconst props = this.props;\r\n    const { store } = this.context;\t\t\r\n\t\tconst state = store.getState();\r\n\r\n\t\treturn (\r\n\t\t  <Link\r\n\t\t\t  active = {\r\n\t\t\t    props.filter === state.visibilityFilter\r\n\t\t\t  }\r\n\t\t\t  onClick={() =>\r\n\t\t\t\t  store.dispatch({\r\n\t\t\t      type: 'SET_VISIBILITY_FILTER',\r\n\t\t\t      filter: props.filter\r\n  \t\t    })\r\n    \t  }\r\n\t    > {props.children}\r\n\t\t\t</Link>\r\n\t\t);\r\n\t}\r\n}\r\n```\r\n\r\n```\r\n\r\nFilterLink.contextTypes = {\r\n  store: React.PropTypes.object\r\n};\r\n\r\n```\r\n\r\nAs the `FilterLink` is self contained to get the `store` from the `context`, we don't have to pass them through the `Footer`.\r\nLet's get rid of it.\r\n\r\n```\r\nconst Footer = () => (\r\n\t\t\t\t<p>\r\n           Show :\r\n             {' '}\r\n             <FilterLink filter = 'SHOW_ALL'>All</FilterLink>\r\n             {' ,  '}\r\n             <FilterLink filter = 'SHOW_ACTIVE'>Active</FilterLink>\r\n             {' ,  '}\r\n             <FilterLink filter = 'SHOW_COMPLETED'>Completed</FilterLink>\r\n        </p>\r\n);\r\n```\r\n\r\nAlso the `TodoApp`\r\n\r\n```\r\nconst TodoApp = () => (\r\n      <div>\r\n\t\t\t  <AddTodo />\r\n        <VisibleTodoList />\r\n\t\t\t\t<Footer />\r\n      </div>\r\n    );\r\n\r\n```\r\n\r\nContext is a powerful feature, but in a way it contradicts the `React` Philosophy of the explicit data flow.\r\nThe Context is essentially a Global Variable across the Component tree, but Global Variables are usually bad idea.\r\n\r\nUnless you use it for Dependency Injection like here what we did to pass a single variable to different components, you shouldn't use it.\r\n\r\nFinally, the context API is not stable in React. It has changed before & likely to change again.\r\nSo try your best not to rely on context too much.\r\n\r\n\r\n## 26. Passing the Store Down with &lt;Provide&gt; from React Redux\r\n\r\n[JS Bin Demo](http://jsbin.com/tulece/edit?html,js,output)\r\n\r\nIn previous step, we've implemented `Provider` which uses React's Context to make the `store` available for every component it wraps.\r\n\r\nIt's so convenient that you don't need to write this `Provider` implementation yourself.\r\n\r\nYou can use a special library  `react-redux`\r\n\r\n```\r\n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/react-redux/4.0.0/react-redux.js\"></script>\r\n```\r\n\r\nThis is redux binding to the react library.\r\n\r\n\r\nGet rid of the `Provider` implementation we wrote with the following piece of code.\r\n\r\n```\r\nconst { Provider } = ReactRedux;\r\n\r\n// import { Provider } from 'react-redux'; // For ES6/Babel, npm\r\n// var Provider = require('react-redux').Provider; // For ES5 Code\r\n\r\n```\r\n\r\n\r\n## 27. Generating Containers with `connect()` from React Redux\r\n\r\n[JS Bin Demo](http://jsbin.com/necaka/edit?html,js,output)\r\n\r\nWe are going to write the `VisibleTodoList` component in a different way.\r\n\r\n\r\n```\r\nconst mapStateToProps = (sate) => {\r\n  return {\r\n\r\n  };\r\n}\r\n```\r\n\r\n`mapStateToProps` takes the Redux's Store state and returns the  `props` it needs to pass to the Presentational `TodoList` component, to render it with the current state.\r\n\r\nIn this case, its a singel `props` called `todos`. Let us copy paste it from the `TodoList` component.\r\n\r\nIt returns the `props` the dependent on the current `state` of the Redux Store.\r\n\r\n```\r\nconst mapStateToProps = (state) => {\r\n  return {\r\n    todos: getVisibleTodos(\r\n              state.todos,\r\n              state.visibilityFilter\r\n              )\r\n  };\r\n};\r\n```\r\n\r\nLet us create another function `mapDispatchToProps`, and it accepts `dispatch` method from the `store` as only argument.\r\nIt returns the `props` thats should be passed to the `TodoList` component and that dependent on the `dispatch` method.\r\n\r\nThe only `prop` which is dependent on `dispatch` method is `onTodoClick`. Let's copy that from `TodoList` Component.\r\n\r\nNote that we will not have reference to `store` anymore.\r\nSo instead of using `store.dispatch()` we are going to use `dispatch` which is provided as an argument to the `mapDispatchToProps`\r\n\r\n```\r\nconst mapDispatchToProps = (dispatch) => {\r\n  return {\r\n    onTodoClick: (id) => {\r\n      dispatch({\r\n        type: 'TOGGLE_TODO',\r\n        id\r\n      })\r\n    }\r\n  };\r\n};\r\n```\r\n\r\nNow we have 2 different functions.\r\n\r\n- `mapStateToProps` - maps the Redux Store state to the `props` of the `TodoList` Component, that are related to the data from the redux store.\r\n\r\n- `mapDispatchToProps` - maps the `dispatch()` of the store, to the callback props of the `TodoList` Component, it specifies the behaviour of which callback props dispatches which action.\r\n\r\nThese 2 functions together can define a **ContainerComponent**.\r\nSo instead of writing our Own **ContainerComponent**, we can generate the same using `react-redux`'s `connect`.\r\n\r\n```\r\nconst { connect } = ReactRedux;\r\n// import { connect } from 'react-redux'; // ES6, Babel\r\n```\r\n\r\nLet us create a variable instead of class, and we'll use the `connect()` method to obtain value for the variable.\r\n\r\n\r\n```\r\nconst VisibleTodoList = connect(\r\n\tmapStateToProps,\r\n\tmapDispatchToProps)(TodoList);\r\n```\r\n\r\nNotice that this is a `connect()` I've to call it once again and this time,\r\nI pass the **PresenationalComponent** that I want to wrap and pass the props to.\r\n\r\nThis `connect()` will create the same component, which we created earlier from scratch.\r\n\r\nHence I don't have to write the code to subscribe to the store or to specify the Context Type, because the `connect` function takes care of it.\r\n\r\n\r\n## 28. Generating Containers with connect() from React Redux (AddTodo)\r\n\r\n[JS Bin Demo](http://jsbin.com/fukira/edit?html,js,output)\r\n\r\nAs we are working on single file which has multiple **ContainerComponents** ,\r\nI would like to rename the `mapStateToProps,mapDispatchToProps` to   `mapStateToTodoListProps,mapDispatchToTodoListProps`\r\n\r\nIn real time, as all the components will have their own file, we can keep the generic names as `mapStateToProps,mapDispatchToProps`\r\nSo the `TodoList` component becomes like this.\r\n```\r\nconst mapStateToTodoListProps = (state) => {\r\n  return {\r\n    todos: getVisibleTodos(\r\n              state.todos,\r\n              state.visibilityFilter\r\n              )\r\n  };\r\n};\r\nconst mapDispatchToTodoListProps = (dispatch) => {\r\n  return {\r\n    onTodoClick: (id) => {\r\n      dispatch({\r\n        type: 'TOGGLE_TODO',\r\n        id\r\n      })\r\n    }\r\n  };\r\n};\r\nconst { connect } = ReactRedux;\r\nconst VisibleTodoList = connect(\r\n\tmapStateToTodoListProps,\r\n\tmapDispatchToTodoListProps)(TodoList);\r\n```\r\n\r\nLets go back to `AddTodo` Component, which is neither a **PresenationalComponent** nor a **ContainerComponent**\r\n\r\n```\r\nlet nextTodoId = 0;\r\n\r\nconst AddTodo = (props, { store }) => {\r\n\tlet input;\r\n\r\n\treturn (\r\n      <div>\r\n        <input ref = { node => {input = node;}}/>\r\n        <button onClick = { () => {\r\n                store.dispatch({\r\n                  type:'ADD_TODO',\r\n                  id:nextTodoId++,\r\n                  text: input.value\r\n                })\r\n\t\t\t\t\t\t\tinput.value = '';\r\n\t\t\t\t\t}}>\r\n\t\t\t\t\t\tAdd Todo\r\n        </button>\r\n\t\t\t</div>\r\n\t\t\t);\r\n};\r\n\r\nAddTodo.contextTypes = {\r\n  store: React.PropTypes.object\r\n};\r\n\r\n```\r\n\r\nHowever, it uses the `Store` through `Context` to dispatch an action when the button is clicked.\r\nIt had to use the `contextTypes` to grab the `store` from the `Context`.\r\n\r\n`Context` is unstable API, and it's advised to avoid it in your application code.\r\n\r\nInstead of reading the store from the `Context`, let us read it from `dispatch()` from the `props`\r\nBecause we only need `dispatch` inside `onClick`. We don't need the whole store.\r\n\r\nLet us create a **ContainerComponent** with `connect()` that will inject the `dispatch()` as prop.\r\nAlso we'll remove the `contextTypes`, which makes the `AddTodo` component like this.\r\n\r\n```\r\nlet nextTodoId = 0;\r\n\r\nlet AddTodo = ({ dispatch }) => {\r\n\tlet input;\r\n\r\n\treturn (\r\n      <div>\r\n        <input ref = { node => {input = node;}}/>\r\n        <button onClick = { () => {\r\n                dispatch({\r\n                  type:'ADD_TODO',\r\n                  id:nextTodoId++,\r\n                  text: input.value\r\n                })\r\n\t\t\t\t\t\t\tinput.value = '';\r\n\t\t\t\t\t}}>\r\n\t\t\t\t\t\tAdd Todo\r\n        </button>\r\n\t\t\t</div>\r\n\t\t\t);\r\n};\r\n\r\n```\r\n\r\nThere are no `props` for `AddTodo`, hence let us return an empty object for the first arg `state`.\r\nIt doesn't need any  callback props; it just accepts `dispatch()` itself, so lets return it as a prop of the same name.\r\n\r\n```\r\nAddTodo = connect(\r\n  state => {\r\n    return {};\r\n    },\r\n    dispatch => {\r\n      return { dispatch };\r\n    }\r\n  )(AddTodo);\r\n```\r\n\r\nThe generated **ContainerComponent** will not pass any props based on state. but it will pass `dispatch()` it self as a function.\r\nSo the component will read it from the props to dispatch action.\r\n\r\nHowever its no use in subscribing to the store, if we don't calculate any props from state.\r\nSo we can make the `mapStateToProps` as null.\r\n```\r\nAddTodo = connect(\r\n  null,\r\n    dispatch => {\r\n      return { dispatch };\r\n    }\r\n  )(AddTodo);\r\n```\r\n\r\nIt is pretty common pattern to inject just the `dispatch()`,\r\nso if you make the 2nd argument as null/falsy value , you are going to get `dispatch()` injected as prop.\r\n\r\n```\r\nAddTodo = connect( null, null )(AddTodo);\r\n```\r\n\r\nIn fact we can remove all args,\r\n\r\n```\r\nAddTodo = connect()(AddTodo);\r\n```\r\n\r\nNow the default behaviour will be, not subscribe to store and to inject just the `dispatch()` function as prop.\r\n\r\n\r\n\r\n## 29. Generating Containers with connect() from React Redux (FooterLink)\r\n\r\n[JS Bin Demo](http://jsbin.com/venaha/edit?html,js,output)\r\n\r\n\r\nLet us refactor `FilterLink` **ContainerComponent** by start writing `mapStateToProps`\r\n\r\nIts going to accept the redux store's `state` as arg and return the props\r\n```\r\nconst mapStateToLinkProps = ( state  ) => {\r\n  return {  active:  props.filter === state.visibilityFilter  }\r\n};\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}